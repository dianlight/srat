/**
 * This file is AUTO GENERATED by [msw-auto-mock](https://github.com/zoubingwu/msw-auto-mock)
 * Feel free to commit/edit it as you need.
 */
/* eslint-disable */
/* tslint:disable */
// @ts-nocheck

import { faker } from "@faker-js/faker";
import { HttpResponse, http } from "msw";

faker.seed(1);

const baseURL = "";
const MAX_ARRAY_LENGTH = 20;

// Map to store counters for each API endpoint
const apiCounters = new Map<string, number>();

const next = (apiKey: string) => {
	let currentCount = apiCounters.get(apiKey) ?? 0;
	if (currentCount === Number.MAX_SAFE_INTEGER - 1) {
		currentCount = 0;
	}
	apiCounters.set(apiKey, currentCount + 1);
	return currentCount;
};

export const handlers = [
	http.get(`${baseURL}/api/capabilities`, async () => {
		const resultArray = [
			[getGetApiCapabilities200Response(), { status: 200 }],
			[getGetApiCapabilities4XxResponse(), { status: 4 }],
			[getGetApiCapabilitiesdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`get /api/capabilities`) % resultArray.length],
		);
	}),
	http.get(`${baseURL}/api/disk/:diskId/hdidle/config`, async () => {
		const resultArray = [
			[getGetApiDiskByDiskIdHdidleConfig200Response(), { status: 200 }],
			[getGetApiDiskByDiskIdHdidleConfig4XxResponse(), { status: 4 }],
			[getGetApiDiskByDiskIdHdidleConfigdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[
				next(`get /api/disk/:diskId/hdidle/config`) % resultArray.length
			],
		);
	}),
	http.patch(`${baseURL}/api/disk/:diskId/hdidle/config`, async () => {
		const resultArray = [
			[getPatchApiDiskByDiskIdHdidleConfig200Response(), { status: 200 }],
			[getPatchApiDiskByDiskIdHdidleConfig4XxResponse(), { status: 4 }],
			[getPatchApiDiskByDiskIdHdidleConfigdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[
				next(`patch /api/disk/:diskId/hdidle/config`) % resultArray.length
			],
		);
	}),
	http.put(`${baseURL}/api/disk/:diskId/hdidle/config`, async () => {
		const resultArray = [
			[getPutApiDiskByDiskIdHdidleConfig200Response(), { status: 200 }],
			[getPutApiDiskByDiskIdHdidleConfig4XxResponse(), { status: 4 }],
			[getPutApiDiskByDiskIdHdidleConfigdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[
				next(`put /api/disk/:diskId/hdidle/config`) % resultArray.length
			],
		);
	}),
	http.get(`${baseURL}/api/disk/:diskId/hdidle/info`, async () => {
		const resultArray = [
			[getGetApiDiskByDiskIdHdidleInfo200Response(), { status: 200 }],
			[getGetApiDiskByDiskIdHdidleInfo4XxResponse(), { status: 4 }],
			[getGetApiDiskByDiskIdHdidleInfodefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[
				next(`get /api/disk/:diskId/hdidle/info`) % resultArray.length
			],
		);
	}),
	http.get(`${baseURL}/api/disk/:diskId/hdidle/support`, async () => {
		const resultArray = [
			[getGetApiDiskByDiskIdHdidleSupport200Response(), { status: 200 }],
			[getGetApiDiskByDiskIdHdidleSupport4XxResponse(), { status: 4 }],
			[getGetApiDiskByDiskIdHdidleSupportdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[
				next(`get /api/disk/:diskId/hdidle/support`) % resultArray.length
			],
		);
	}),
	http.post(`${baseURL}/api/disk/:diskId/smart/disable`, async () => {
		const resultArray = [
			[getPostApiDiskByDiskIdSmartDisable200Response(), { status: 200 }],
			[getPostApiDiskByDiskIdSmartDisable4XxResponse(), { status: 4 }],
			[getPostApiDiskByDiskIdSmartDisabledefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[
				next(`post /api/disk/:diskId/smart/disable`) % resultArray.length
			],
		);
	}),
	http.post(`${baseURL}/api/disk/:diskId/smart/enable`, async () => {
		const resultArray = [
			[getPostApiDiskByDiskIdSmartEnable200Response(), { status: 200 }],
			[getPostApiDiskByDiskIdSmartEnable4XxResponse(), { status: 4 }],
			[getPostApiDiskByDiskIdSmartEnabledefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[
				next(`post /api/disk/:diskId/smart/enable`) % resultArray.length
			],
		);
	}),
	http.get(`${baseURL}/api/disk/:diskId/smart/health`, async () => {
		const resultArray = [
			[getGetApiDiskByDiskIdSmartHealth200Response(), { status: 200 }],
			[getGetApiDiskByDiskIdSmartHealth4XxResponse(), { status: 4 }],
			[getGetApiDiskByDiskIdSmartHealthdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[
				next(`get /api/disk/:diskId/smart/health`) % resultArray.length
			],
		);
	}),
	http.get(`${baseURL}/api/disk/:diskId/smart/info`, async () => {
		const resultArray = [
			[getGetApiDiskByDiskIdSmartInfo200Response(), { status: 200 }],
			[getGetApiDiskByDiskIdSmartInfo4XxResponse(), { status: 4 }],
			[getGetApiDiskByDiskIdSmartInfodefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[
				next(`get /api/disk/:diskId/smart/info`) % resultArray.length
			],
		);
	}),
	http.get(`${baseURL}/api/disk/:diskId/smart/status`, async () => {
		const resultArray = [
			[getGetApiDiskByDiskIdSmartStatus200Response(), { status: 200 }],
			[getGetApiDiskByDiskIdSmartStatus4XxResponse(), { status: 4 }],
			[getGetApiDiskByDiskIdSmartStatusdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[
				next(`get /api/disk/:diskId/smart/status`) % resultArray.length
			],
		);
	}),
	http.get(`${baseURL}/api/disk/:diskId/smart/test`, async () => {
		const resultArray = [
			[getGetApiDiskByDiskIdSmartTest200Response(), { status: 200 }],
			[getGetApiDiskByDiskIdSmartTest4XxResponse(), { status: 4 }],
			[getGetApiDiskByDiskIdSmartTestdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[
				next(`get /api/disk/:diskId/smart/test`) % resultArray.length
			],
		);
	}),
	http.post(`${baseURL}/api/disk/:diskId/smart/test/abort`, async () => {
		const resultArray = [
			[getPostApiDiskByDiskIdSmartTestAbort200Response(), { status: 200 }],
			[getPostApiDiskByDiskIdSmartTestAbort4XxResponse(), { status: 4 }],
			[getPostApiDiskByDiskIdSmartTestAbortdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[
				next(`post /api/disk/:diskId/smart/test/abort`) % resultArray.length
			],
		);
	}),
	http.post(`${baseURL}/api/disk/:diskId/smart/test/start`, async () => {
		const resultArray = [
			[getPostApiDiskByDiskIdSmartTestStart200Response(), { status: 200 }],
			[getPostApiDiskByDiskIdSmartTestStart4XxResponse(), { status: 4 }],
			[getPostApiDiskByDiskIdSmartTestStartdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[
				next(`post /api/disk/:diskId/smart/test/start`) % resultArray.length
			],
		);
	}),
	http.get(`${baseURL}/api/filesystems`, async () => {
		const resultArray = [
			[getListApiFilesystems200Response(), { status: 200 }],
			[getListApiFilesystems4XxResponse(), { status: 4 }],
			[getListApiFilesystemsdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`get /api/filesystems`) % resultArray.length],
		);
	}),
	http.post(`${baseURL}/api/hdidle/start`, async () => {
		const resultArray = [
			[getPostApiHdidleStart200Response(), { status: 200 }],
			[getPostApiHdidleStart4XxResponse(), { status: 4 }],
			[getPostApiHdidleStartdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`post /api/hdidle/start`) % resultArray.length],
		);
	}),
	http.post(`${baseURL}/api/hdidle/stop`, async () => {
		const resultArray = [
			[getPostApiHdidleStop200Response(), { status: 200 }],
			[getPostApiHdidleStop4XxResponse(), { status: 4 }],
			[getPostApiHdidleStopdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`post /api/hdidle/stop`) % resultArray.length],
		);
	}),
	http.get(`${baseURL}/api/health`, async () => {
		const resultArray = [
			[getGetApiHealth200Response(), { status: 200 }],
			[getGetApiHealth4XxResponse(), { status: 4 }],
			[getGetApiHealthdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`get /api/health`) % resultArray.length],
		);
	}),
	http.get(`${baseURL}/api/hostname`, async () => {
		const resultArray = [
			[getGetApiHostname200Response(), { status: 200 }],
			[getGetApiHostname4XxResponse(), { status: 4 }],
			[getGetApiHostnamedefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`get /api/hostname`) % resultArray.length],
		);
	}),
	http.get(`${baseURL}/api/issues`, async () => {
		const resultArray = [
			[getGetIssues200Response(), { status: 200 }],
			[getGetIssues4XxResponse(), { status: 4 }],
			[getGetIssuesdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`get /api/issues`) % resultArray.length],
		);
	}),
	http.post(`${baseURL}/api/issues`, async () => {
		const resultArray = [
			[getCreateIssue200Response(), { status: 200 }],
			[getCreateIssue4XxResponse(), { status: 4 }],
			[getCreateIssuedefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`post /api/issues`) % resultArray.length],
		);
	}),
	http.post(`${baseURL}/api/issues/report`, async () => {
		const resultArray = [
			[getGenerateIssueReport200Response(), { status: 200 }],
			[getGenerateIssueReport4XxResponse(), { status: 4 }],
			[getGenerateIssueReportdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`post /api/issues/report`) % resultArray.length],
		);
	}),
	http.get(`${baseURL}/api/issues/template`, async () => {
		const resultArray = [
			[getGetIssueTemplate200Response(), { status: 200 }],
			[getGetIssueTemplate4XxResponse(), { status: 4 }],
			[getGetIssueTemplatedefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`get /api/issues/template`) % resultArray.length],
		);
	}),
	http.delete(`${baseURL}/api/issues/:id`, async () => {
		const resultArray = [
			[undefined, { status: 204 }],
			[getResolveIssue4XxResponse(), { status: 4 }],
			[getResolveIssuedefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`delete /api/issues/:id`) % resultArray.length],
		);
	}),
	http.put(`${baseURL}/api/issues/:id`, async () => {
		const resultArray = [
			[getUpdateIssue200Response(), { status: 200 }],
			[getUpdateIssue4XxResponse(), { status: 4 }],
			[getUpdateIssuedefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`put /api/issues/:id`) % resultArray.length],
		);
	}),
	http.get(`${baseURL}/api/nics`, async () => {
		const resultArray = [
			[getListApiNics200Response(), { status: 200 }],
			[getListApiNics4XxResponse(), { status: 4 }],
			[getListApiNicsdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`get /api/nics`) % resultArray.length],
		);
	}),
	http.put(`${baseURL}/api/restart`, async () => {
		const resultArray = [
			[undefined, { status: 204 }],
			[getPutApiRestart4XxResponse(), { status: 4 }],
			[getPutApiRestartdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`put /api/restart`) % resultArray.length],
		);
	}),
	http.put(`${baseURL}/api/samba/apply`, async () => {
		const resultArray = [
			[undefined, { status: 204 }],
			[getPutApiSambaApply4XxResponse(), { status: 4 }],
			[getPutApiSambaApplydefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`put /api/samba/apply`) % resultArray.length],
		);
	}),
	http.get(`${baseURL}/api/samba/config`, async () => {
		const resultArray = [
			[getGetApiSambaConfig200Response(), { status: 200 }],
			[getGetApiSambaConfig4XxResponse(), { status: 4 }],
			[getGetApiSambaConfigdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`get /api/samba/config`) % resultArray.length],
		);
	}),
	http.get(`${baseURL}/api/samba/status`, async () => {
		const resultArray = [
			[getGetApiSambaStatus200Response(), { status: 200 }],
			[getGetApiSambaStatus4XxResponse(), { status: 4 }],
			[getGetApiSambaStatusdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`get /api/samba/status`) % resultArray.length],
		);
	}),
	http.get(`${baseURL}/api/settings`, async () => {
		const resultArray = [
			[getGetApiSettings200Response(), { status: 200 }],
			[getGetApiSettings4XxResponse(), { status: 4 }],
			[getGetApiSettingsdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`get /api/settings`) % resultArray.length],
		);
	}),
	http.patch(`${baseURL}/api/settings`, async () => {
		const resultArray = [
			[getPatchApiSettings200Response(), { status: 200 }],
			[getPatchApiSettings4XxResponse(), { status: 4 }],
			[getPatchApiSettingsdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`patch /api/settings`) % resultArray.length],
		);
	}),
	http.put(`${baseURL}/api/settings`, async () => {
		const resultArray = [
			[getPutApiSettings200Response(), { status: 200 }],
			[getPutApiSettings4XxResponse(), { status: 4 }],
			[getPutApiSettingsdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`put /api/settings`) % resultArray.length],
		);
	}),
	http.post(`${baseURL}/api/share`, async () => {
		const resultArray = [
			[getPostApiShare200Response(), { status: 200 }],
			[getPostApiShare4XxResponse(), { status: 4 }],
			[getPostApiSharedefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`post /api/share`) % resultArray.length],
		);
	}),
	http.delete(`${baseURL}/api/share/:shareName`, async () => {
		const resultArray = [
			[undefined, { status: 204 }],
			[getDeleteApiShareByShareName4XxResponse(), { status: 4 }],
			[getDeleteApiShareByShareNamedefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`delete /api/share/:shareName`) % resultArray.length],
		);
	}),
	http.get(`${baseURL}/api/share/:shareName`, async () => {
		const resultArray = [
			[getGetApiShareByShareName200Response(), { status: 200 }],
			[getGetApiShareByShareName4XxResponse(), { status: 4 }],
			[getGetApiShareByShareNamedefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`get /api/share/:shareName`) % resultArray.length],
		);
	}),
	http.patch(`${baseURL}/api/share/:shareName`, async () => {
		const resultArray = [
			[getPatchApiShareByShareName200Response(), { status: 200 }],
			[getPatchApiShareByShareName4XxResponse(), { status: 4 }],
			[getPatchApiShareByShareNamedefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`patch /api/share/:shareName`) % resultArray.length],
		);
	}),
	http.put(`${baseURL}/api/share/:shareName`, async () => {
		const resultArray = [
			[getPutApiShareByShareName200Response(), { status: 200 }],
			[getPutApiShareByShareName4XxResponse(), { status: 4 }],
			[getPutApiShareByShareNamedefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`put /api/share/:shareName`) % resultArray.length],
		);
	}),
	http.put(`${baseURL}/api/share/:shareName/disable`, async () => {
		const resultArray = [
			[getPutApiShareByShareNameDisable200Response(), { status: 200 }],
			[getPutApiShareByShareNameDisable4XxResponse(), { status: 4 }],
			[getPutApiShareByShareNameDisabledefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[
				next(`put /api/share/:shareName/disable`) % resultArray.length
			],
		);
	}),
	http.put(`${baseURL}/api/share/:shareName/enable`, async () => {
		const resultArray = [
			[getPutApiShareByShareNameEnable200Response(), { status: 200 }],
			[getPutApiShareByShareNameEnable4XxResponse(), { status: 4 }],
			[getPutApiShareByShareNameEnabledefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[
				next(`put /api/share/:shareName/enable`) % resultArray.length
			],
		);
	}),
	http.get(`${baseURL}/api/shares`, async () => {
		const resultArray = [
			[getListApiShares200Response(), { status: 200 }],
			[getListApiShares4XxResponse(), { status: 4 }],
			[getListApiSharesdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`get /api/shares`) % resultArray.length],
		);
	}),
	http.get(`${baseURL}/api/sse`, async () => {
		const resultArray = [
			[getSse200Response(), { status: 200 }],
			[getSse4XxResponse(), { status: 4 }],
			[getSsedefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`get /api/sse`) % resultArray.length],
		);
	}),
	http.get(`${baseURL}/api/status`, async () => {
		const resultArray = [
			[getGetApiStatus200Response(), { status: 200 }],
			[getGetApiStatus4XxResponse(), { status: 4 }],
			[getGetApiStatusdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`get /api/status`) % resultArray.length],
		);
	}),
	http.get(`${baseURL}/api/telemetry/internet-connection`, async () => {
		const resultArray = [
			[getGetApiTelemetryInternetConnection200Response(), { status: 200 }],
			[getGetApiTelemetryInternetConnection4XxResponse(), { status: 4 }],
			[getGetApiTelemetryInternetConnectiondefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[
				next(`get /api/telemetry/internet-connection`) % resultArray.length
			],
		);
	}),
	http.get(`${baseURL}/api/telemetry/modes`, async () => {
		const resultArray = [
			[getListApiTelemetryModes200Response(), { status: 200 }],
			[getListApiTelemetryModes4XxResponse(), { status: 4 }],
			[getListApiTelemetryModesdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`get /api/telemetry/modes`) % resultArray.length],
		);
	}),
	http.get(`${baseURL}/api/update`, async () => {
		const resultArray = [
			[getGetApiUpdate200Response(), { status: 200 }],
			[getGetApiUpdate4XxResponse(), { status: 4 }],
			[getGetApiUpdatedefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`get /api/update`) % resultArray.length],
		);
	}),
	http.put(`${baseURL}/api/update`, async () => {
		const resultArray = [
			[getPutApiUpdate200Response(), { status: 200 }],
			[getPutApiUpdate4XxResponse(), { status: 4 }],
			[getPutApiUpdatedefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`put /api/update`) % resultArray.length],
		);
	}),
	http.get(`${baseURL}/api/update_channels`, async () => {
		const resultArray = [
			[getListApiUpdateChannels200Response(), { status: 200 }],
			[getListApiUpdateChannels4XxResponse(), { status: 4 }],
			[getListApiUpdateChannelsdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`get /api/update_channels`) % resultArray.length],
		);
	}),
	http.post(`${baseURL}/api/user`, async () => {
		const resultArray = [
			[getPostApiUser200Response(), { status: 200 }],
			[getPostApiUser4XxResponse(), { status: 4 }],
			[getPostApiUserdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`post /api/user`) % resultArray.length],
		);
	}),
	http.delete(`${baseURL}/api/user/:username`, async () => {
		const resultArray = [
			[undefined, { status: 204 }],
			[getDeleteApiUserByUsername4XxResponse(), { status: 4 }],
			[getDeleteApiUserByUsernamedefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`delete /api/user/:username`) % resultArray.length],
		);
	}),
	http.put(`${baseURL}/api/user/:username`, async () => {
		const resultArray = [
			[getPutApiUserByUsername200Response(), { status: 200 }],
			[getPutApiUserByUsername4XxResponse(), { status: 4 }],
			[getPutApiUserByUsernamedefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`put /api/user/:username`) % resultArray.length],
		);
	}),
	http.put(`${baseURL}/api/useradmin`, async () => {
		const resultArray = [
			[getPutApiUseradmin200Response(), { status: 200 }],
			[getPutApiUseradmin4XxResponse(), { status: 4 }],
			[getPutApiUseradmindefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`put /api/useradmin`) % resultArray.length],
		);
	}),
	http.get(`${baseURL}/api/users`, async () => {
		const resultArray = [
			[getListApiUsers200Response(), { status: 200 }],
			[getListApiUsers4XxResponse(), { status: 4 }],
			[getListApiUsersdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`get /api/users`) % resultArray.length],
		);
	}),
	http.delete(`${baseURL}/api/volume`, async () => {
		const resultArray = [
			[undefined, { status: 204 }],
			[getDeleteApiVolume4XxResponse(), { status: 4 }],
			[getDeleteApiVolumedefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`delete /api/volume`) % resultArray.length],
		);
	}),
	http.post(`${baseURL}/api/volume/mount`, async () => {
		const resultArray = [
			[getPostApiVolumeMount200Response(), { status: 200 }],
			[getPostApiVolumeMount4XxResponse(), { status: 4 }],
			[getPostApiVolumeMountdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`post /api/volume/mount`) % resultArray.length],
		);
	}),
	http.patch(`${baseURL}/api/volume/settings`, async () => {
		const resultArray = [
			[getPatchApiVolumeSettings200Response(), { status: 200 }],
			[getPatchApiVolumeSettings4XxResponse(), { status: 4 }],
			[getPatchApiVolumeSettingsdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`patch /api/volume/settings`) % resultArray.length],
		);
	}),
	http.get(`${baseURL}/api/volumes`, async () => {
		const resultArray = [
			[getListApiVolumes200Response(), { status: 200 }],
			[getListApiVolumes4XxResponse(), { status: 4 }],
			[getListApiVolumesdefaultResponse(), { status: NaN }],
		] as [any, { status: number }][];

		return HttpResponse.json(
			...resultArray[next(`get /api/volumes`) % resultArray.length],
		);
	}),
];

export function getGetApiCapabilities200Response() {
	return {
		$schema: faker.internet.url(),
		has_kernel_module: faker.datatype.boolean(),
		samba_version: faker.lorem.words(),
		samba_version_sufficient: faker.datatype.boolean(),
		supports_quic: faker.datatype.boolean(),
		unsupported_reason: faker.lorem.words(),
	};
}

export function getGetApiCapabilities4XxResponse() {
	return null;
}

export function getGetApiCapabilitiesdefaultResponse() {
	return null;
}

export function getGetApiDiskByDiskIdHdidleConfig200Response() {
	return {
		$schema: faker.internet.url(),
		command_type: faker.helpers.arrayElement(["scsi", "ata"]),
		device_path: faker.lorem.words(),
		disk_id: faker.string.uuid(),
		enabled: faker.helpers.arrayElement(["yes", "custom", "no"]),
		error_message: faker.lorem.words(),
		idle_time: faker.number.int(),
		power_condition: faker.number.int(),
		recommended_command: faker.lorem.words(),
		supported: faker.datatype.boolean(),
		supports_ata: faker.datatype.boolean(),
		supports_scsi: faker.datatype.boolean(),
	};
}

export function getGetApiDiskByDiskIdHdidleConfig4XxResponse() {
	return null;
}

export function getGetApiDiskByDiskIdHdidleConfigdefaultResponse() {
	return null;
}

export function getPatchApiDiskByDiskIdHdidleConfig200Response() {
	return {
		$schema: faker.internet.url(),
		command_type: faker.helpers.arrayElement(["scsi", "ata"]),
		device_path: faker.lorem.words(),
		disk_id: faker.string.uuid(),
		enabled: faker.helpers.arrayElement(["yes", "custom", "no"]),
		error_message: faker.lorem.words(),
		idle_time: faker.number.int(),
		power_condition: faker.number.int(),
		recommended_command: faker.lorem.words(),
		supported: faker.datatype.boolean(),
		supports_ata: faker.datatype.boolean(),
		supports_scsi: faker.datatype.boolean(),
	};
}

export function getPatchApiDiskByDiskIdHdidleConfig4XxResponse() {
	return null;
}

export function getPatchApiDiskByDiskIdHdidleConfigdefaultResponse() {
	return null;
}

export function getPutApiDiskByDiskIdHdidleConfig200Response() {
	return {
		$schema: faker.internet.url(),
		command_type: faker.helpers.arrayElement(["scsi", "ata"]),
		device_path: faker.lorem.words(),
		disk_id: faker.string.uuid(),
		enabled: faker.helpers.arrayElement(["yes", "custom", "no"]),
		error_message: faker.lorem.words(),
		idle_time: faker.number.int(),
		power_condition: faker.number.int(),
		recommended_command: faker.lorem.words(),
		supported: faker.datatype.boolean(),
		supports_ata: faker.datatype.boolean(),
		supports_scsi: faker.datatype.boolean(),
	};
}

export function getPutApiDiskByDiskIdHdidleConfig4XxResponse() {
	return null;
}

export function getPutApiDiskByDiskIdHdidleConfigdefaultResponse() {
	return null;
}

export function getGetApiDiskByDiskIdHdidleInfo200Response() {
	return {
		$schema: faker.internet.url(),
		last_io_at: faker.date.past(),
		name: faker.person.fullName(),
		spin_down_at: faker.date.past(),
		spin_up_at: faker.date.past(),
		spun_down: faker.datatype.boolean(),
	};
}

export function getGetApiDiskByDiskIdHdidleInfo4XxResponse() {
	return null;
}

export function getGetApiDiskByDiskIdHdidleInfodefaultResponse() {
	return null;
}

export function getGetApiDiskByDiskIdHdidleSupport200Response() {
	return {
		$schema: faker.internet.url(),
		device_path: faker.lorem.words(),
		error_message: faker.lorem.words(),
		recommended_command: faker.lorem.words(),
		supported: faker.datatype.boolean(),
		supports_ata: faker.datatype.boolean(),
		supports_scsi: faker.datatype.boolean(),
	};
}

export function getGetApiDiskByDiskIdHdidleSupport4XxResponse() {
	return null;
}

export function getGetApiDiskByDiskIdHdidleSupportdefaultResponse() {
	return null;
}

export function getPostApiDiskByDiskIdSmartDisable200Response() {
	return faker.lorem.words();
}

export function getPostApiDiskByDiskIdSmartDisable4XxResponse() {
	return null;
}

export function getPostApiDiskByDiskIdSmartDisabledefaultResponse() {
	return null;
}

export function getPostApiDiskByDiskIdSmartEnable200Response() {
	return faker.lorem.words();
}

export function getPostApiDiskByDiskIdSmartEnable4XxResponse() {
	return null;
}

export function getPostApiDiskByDiskIdSmartEnabledefaultResponse() {
	return null;
}

export function getGetApiDiskByDiskIdSmartHealth200Response() {
	return {
		$schema: faker.internet.url(),
		failing_attributes: faker.helpers.arrayElement([
			[
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => faker.lorem.words()),
			null,
		]),
		overall_status: faker.lorem.words(),
		passed: faker.datatype.boolean(),
	};
}

export function getGetApiDiskByDiskIdSmartHealth4XxResponse() {
	return null;
}

export function getGetApiDiskByDiskIdSmartHealthdefaultResponse() {
	return null;
}

export function getGetApiDiskByDiskIdSmartInfo200Response() {
	return {
		$schema: faker.internet.url(),
		disk_id: faker.string.uuid(),
		disk_type: faker.helpers.arrayElement(["SATA", "NVMe", "SCSI", "Unknown"]),
		firmware_version: faker.lorem.words(),
		model_family: faker.lorem.words(),
		model_name: faker.person.fullName(),
		rotation_rate: faker.number.int(),
		serial_number: faker.lorem.words(),
		supported: faker.datatype.boolean(),
	};
}

export function getGetApiDiskByDiskIdSmartInfo4XxResponse() {
	return null;
}

export function getGetApiDiskByDiskIdSmartInfodefaultResponse() {
	return null;
}

export function getGetApiDiskByDiskIdSmartStatus200Response() {
	return {
		$schema: faker.internet.url(),
		enabled: faker.datatype.boolean(),
		in_standby: faker.datatype.boolean(),
		is_in_danger: faker.datatype.boolean(),
		is_in_warning: faker.datatype.boolean(),
		is_test_passed: faker.datatype.boolean(),
		is_test_running: faker.datatype.boolean(),
		others: [...new Array(5).keys()]
			.map((_) => ({
				[faker.lorem.word()]: {
					code: faker.number.int(),
					min: faker.number.int(),
					thresholds: faker.number.int(),
					value: faker.number.int(),
					worst: faker.number.int(),
				},
			}))
			.reduce((acc, next) => Object.assign(acc, next), {}),
		power_cycle_count: {
			code: faker.number.int(),
			min: faker.number.int(),
			thresholds: faker.number.int(),
			value: faker.number.int(),
			worst: faker.number.int(),
		},
		power_on_hours: {
			code: faker.number.int(),
			min: faker.number.int(),
			thresholds: faker.number.int(),
			value: faker.number.int(),
			worst: faker.number.int(),
		},
		temperature: {
			max: faker.number.int(),
			min: faker.number.int(),
			overtemp_counter: faker.number.int(),
			value: faker.number.int(),
		},
	};
}

export function getGetApiDiskByDiskIdSmartStatus4XxResponse() {
	return null;
}

export function getGetApiDiskByDiskIdSmartStatusdefaultResponse() {
	return null;
}

export function getGetApiDiskByDiskIdSmartTest200Response() {
	return {
		$schema: faker.internet.url(),
		disk_id: faker.string.uuid(),
		lba_of_first_error: faker.lorem.words(),
		percent_complete: faker.number.int(),
		running: faker.datatype.boolean(),
		status: faker.lorem.words(),
		test_type: faker.lorem.words(),
	};
}

export function getGetApiDiskByDiskIdSmartTest4XxResponse() {
	return null;
}

export function getGetApiDiskByDiskIdSmartTestdefaultResponse() {
	return null;
}

export function getPostApiDiskByDiskIdSmartTestAbort200Response() {
	return faker.lorem.words();
}

export function getPostApiDiskByDiskIdSmartTestAbort4XxResponse() {
	return null;
}

export function getPostApiDiskByDiskIdSmartTestAbortdefaultResponse() {
	return null;
}

export function getPostApiDiskByDiskIdSmartTestStart200Response() {
	return faker.lorem.words();
}

export function getPostApiDiskByDiskIdSmartTestStart4XxResponse() {
	return null;
}

export function getPostApiDiskByDiskIdSmartTestStartdefaultResponse() {
	return null;
}

export function getListApiFilesystems200Response() {
	return faker.helpers.arrayElement([
		[
			...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
		].map((_) => null),
		null,
	]);
}

export function getListApiFilesystems4XxResponse() {
	return null;
}

export function getListApiFilesystemsdefaultResponse() {
	return null;
}

export function getPostApiHdidleStart200Response() {
	return {
		$schema: faker.internet.url(),
		message: faker.lorem.words(),
		running: faker.datatype.boolean(),
	};
}

export function getPostApiHdidleStart4XxResponse() {
	return null;
}

export function getPostApiHdidleStartdefaultResponse() {
	return null;
}

export function getPostApiHdidleStop200Response() {
	return {
		$schema: faker.internet.url(),
		message: faker.lorem.words(),
		running: faker.datatype.boolean(),
	};
}

export function getPostApiHdidleStop4XxResponse() {
	return null;
}

export function getPostApiHdidleStopdefaultResponse() {
	return null;
}

export function getGetApiHealth200Response() {
	return {
		$schema: faker.internet.url(),
		addon_stats: {
			blk_read: faker.number.int(),
			blk_write: faker.number.int(),
			cpu_percent: faker.number.int(),
			memory_limit: faker.number.int(),
			memory_percent: faker.number.int(),
			memory_usage: faker.number.int(),
			network_rx: faker.number.int(),
			network_tx: faker.number.int(),
		},
		alive: faker.datatype.boolean(),
		aliveTime: faker.number.int(),
		dirty_tracking: {
			settings: faker.datatype.boolean(),
			shares: faker.datatype.boolean(),
			users: faker.datatype.boolean(),
		},
		disk_health: {
			global: {
				total_iops: faker.number.int(),
				total_read_latency_ms: faker.number.int(),
				total_write_latency_ms: faker.number.int(),
			},
			hdidle_running: faker.datatype.boolean(),
			per_disk_info: [...new Array(5).keys()]
				.map((_) => ({
					[faker.lorem.word()]: {
						device_id: faker.string.uuid(),
						device_path: faker.lorem.words(),
						hdidle_status: {
							$schema: faker.internet.url(),
							last_io_at: faker.date.past(),
							name: faker.person.fullName(),
							spin_down_at: faker.date.past(),
							spin_up_at: faker.date.past(),
							spun_down: faker.datatype.boolean(),
						},
						smart_health: {
							$schema: faker.internet.url(),
							failing_attributes: faker.helpers.arrayElement([
								[
									...new Array(
										faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
									).keys(),
								].map((_) => faker.lorem.words()),
								null,
							]),
							overall_status: faker.lorem.words(),
							passed: faker.datatype.boolean(),
						},
						smart_info: {
							$schema: faker.internet.url(),
							disk_id: faker.string.uuid(),
							disk_type: faker.helpers.arrayElement([
								"SATA",
								"NVMe",
								"SCSI",
								"Unknown",
							]),
							firmware_version: faker.lorem.words(),
							model_family: faker.lorem.words(),
							model_name: faker.person.fullName(),
							rotation_rate: faker.number.int(),
							serial_number: faker.lorem.words(),
							supported: faker.datatype.boolean(),
						},
					},
				}))
				.reduce((acc, next) => Object.assign(acc, next), {}),
			per_disk_io: faker.helpers.arrayElement([
				[
					...new Array(
						faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
					).keys(),
				].map((_) => null),
				null,
			]),
			per_partition_info: [...new Array(5).keys()]
				.map((_) => ({
					[faker.lorem.word()]: faker.helpers.arrayElement([
						[
							...new Array(
								faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
							).keys(),
						].map((_) => null),
						null,
					]),
				}))
				.reduce((acc, next) => Object.assign(acc, next), {}),
		},
		last_error: faker.lorem.words(),
		network_health: {
			global: {
				totalInboundTraffic: faker.number.int(),
				totalOutboundTraffic: faker.number.int(),
			},
			perNicIO: faker.helpers.arrayElement([
				[
					...new Array(
						faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
					).keys(),
				].map((_) => null),
				null,
			]),
		},
		samba_process_status: [...new Array(5).keys()]
			.map((_) => ({
				[faker.lorem.word()]: {
					children: faker.helpers.arrayElement([
						[
							...new Array(
								faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
							).keys(),
						].map((_) => null),
						null,
					]),
					connections: faker.number.int(),
					cpu_percent: faker.number.int(),
					create_time: faker.date.past(),
					is_running: faker.datatype.boolean(),
					memory_percent: faker.number.int(),
					name: faker.person.fullName(),
					open_files: faker.number.int(),
					pid: faker.number.int(),
					status: faker.helpers.arrayElement([
						[
							...new Array(
								faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
							).keys(),
						].map((_) => faker.lorem.words()),
						null,
					]),
				},
			}))
			.reduce((acc, next) => Object.assign(acc, next), {}),
		samba_status: {
			$schema: faker.internet.url(),
			sessions: [...new Array(5).keys()]
				.map((_) => ({
					[faker.lorem.word()]: {
						auth_time: faker.lorem.words(),
						channels: [...new Array(5).keys()]
							.map((_) => ({
								[faker.lorem.word()]: {
									channel_id: faker.string.uuid(),
									creation_time: faker.lorem.words(),
									local_address: faker.lorem.words(),
									remote_address: faker.lorem.words(),
								},
							}))
							.reduce((acc, next) => Object.assign(acc, next), {}),
						creation_time: faker.lorem.words(),
						encryption: {
							cipher: faker.lorem.words(),
							degree: faker.lorem.words(),
						},
						gid: faker.number.int(),
						groupname: faker.person.fullName(),
						hostname: faker.person.fullName(),
						remote_machine: faker.lorem.words(),
						server_id: {
							pid: faker.string.uuid(),
							task_id: faker.string.uuid(),
							unique_id: faker.string.uuid(),
							vnn: faker.lorem.words(),
						},
						session_dialect: faker.lorem.words(),
						session_id: faker.string.uuid(),
						signing: {
							cipher: faker.lorem.words(),
							degree: faker.lorem.words(),
						},
						uid: faker.number.int(),
						username: faker.person.fullName(),
					},
				}))
				.reduce((acc, next) => Object.assign(acc, next), {}),
			smb_conf: faker.lorem.words(),
			tcons: [...new Array(5).keys()]
				.map((_) => ({
					[faker.lorem.word()]: {
						connected_at: faker.date.past(),
						device: faker.lorem.words(),
						encryption: {
							cipher: faker.lorem.words(),
							degree: faker.lorem.words(),
						},
						machine: faker.lorem.words(),
						server_id: {
							pid: faker.string.uuid(),
							task_id: faker.string.uuid(),
							unique_id: faker.string.uuid(),
							vnn: faker.lorem.words(),
						},
						service: faker.lorem.words(),
						session_id: faker.string.uuid(),
						share: faker.lorem.words(),
						signing: {
							cipher: faker.lorem.words(),
							degree: faker.lorem.words(),
						},
						tcon_id: faker.string.uuid(),
					},
				}))
				.reduce((acc, next) => Object.assign(acc, next), {}),
			timestamp: faker.lorem.words(),
			version: faker.lorem.words(),
		},
		update_available: faker.datatype.boolean(),
		uptime: faker.number.int(),
	};
}

export function getGetApiHealth4XxResponse() {
	return null;
}

export function getGetApiHealthdefaultResponse() {
	return null;
}

export function getGetApiHostname200Response() {
	return faker.lorem.words();
}

export function getGetApiHostname4XxResponse() {
	return null;
}

export function getGetApiHostnamedefaultResponse() {
	return null;
}

export function getGetIssues200Response() {
	return faker.helpers.arrayElement([
		[
			...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
		].map((_) => null),
		null,
	]);
}

export function getGetIssues4XxResponse() {
	return null;
}

export function getGetIssuesdefaultResponse() {
	return null;
}

export function getCreateIssue200Response() {
	return {
		$schema: faker.internet.url(),
		date: faker.date.past(),
		description: faker.lorem.words(),
		detailLink: faker.lorem.words(),
		id: faker.number.int(),
		ignored: faker.datatype.boolean(),
		repeating: faker.number.int(),
		resolutionLink: faker.lorem.words(),
		severity: faker.helpers.arrayElement([
			"error",
			"warning",
			"info",
			"success",
		]),
		title: faker.lorem.words(),
	};
}

export function getCreateIssue4XxResponse() {
	return null;
}

export function getCreateIssuedefaultResponse() {
	return null;
}

export function getGenerateIssueReport200Response() {
	return {
		$schema: faker.internet.url(),
		addon_logs: faker.lorem.words(),
		database_dump: faker.lorem.words(),
		github_url: faker.internet.url(),
		issue_title: faker.lorem.words(),
		sanitized_addon_config: faker.lorem.words(),
		sanitized_srat_config: faker.lorem.words(),
	};
}

export function getGenerateIssueReport4XxResponse() {
	return null;
}

export function getGenerateIssueReportdefaultResponse() {
	return null;
}

export function getGetIssueTemplate200Response() {
	return {
		$schema: faker.internet.url(),
		error: faker.lorem.words(),
		template: {
			body: faker.helpers.arrayElement([
				[
					...new Array(
						faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
					).keys(),
				].map((_) => null),
				null,
			]),
			description: faker.lorem.words(),
			labels: faker.helpers.arrayElement([
				[
					...new Array(
						faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
					).keys(),
				].map((_) => faker.lorem.words()),
				null,
			]),
			name: faker.person.fullName(),
			title: faker.lorem.words(),
		},
	};
}

export function getGetIssueTemplate4XxResponse() {
	return null;
}

export function getGetIssueTemplatedefaultResponse() {
	return null;
}

export function getResolveIssue4XxResponse() {
	return null;
}

export function getResolveIssuedefaultResponse() {
	return null;
}

export function getUpdateIssue200Response() {
	return {
		$schema: faker.internet.url(),
		date: faker.date.past(),
		description: faker.lorem.words(),
		detailLink: faker.lorem.words(),
		id: faker.number.int(),
		ignored: faker.datatype.boolean(),
		repeating: faker.number.int(),
		resolutionLink: faker.lorem.words(),
		severity: faker.helpers.arrayElement([
			"error",
			"warning",
			"info",
			"success",
		]),
		title: faker.lorem.words(),
	};
}

export function getUpdateIssue4XxResponse() {
	return null;
}

export function getUpdateIssuedefaultResponse() {
	return null;
}

export function getListApiNics200Response() {
	return faker.helpers.arrayElement([
		[
			...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
		].map((_) => null),
		null,
	]);
}

export function getListApiNics4XxResponse() {
	return null;
}

export function getListApiNicsdefaultResponse() {
	return null;
}

export function getPutApiRestart4XxResponse() {
	return null;
}

export function getPutApiRestartdefaultResponse() {
	return null;
}

export function getPutApiSambaApply4XxResponse() {
	return null;
}

export function getPutApiSambaApplydefaultResponse() {
	return null;
}

export function getGetApiSambaConfig200Response() {
	return {
		$schema: faker.internet.url(),
		data: faker.lorem.words(),
	};
}

export function getGetApiSambaConfig4XxResponse() {
	return null;
}

export function getGetApiSambaConfigdefaultResponse() {
	return null;
}

export function getGetApiSambaStatus200Response() {
	return {
		$schema: faker.internet.url(),
		sessions: [...new Array(5).keys()]
			.map((_) => ({
				[faker.lorem.word()]: {
					auth_time: faker.lorem.words(),
					channels: [...new Array(5).keys()]
						.map((_) => ({
							[faker.lorem.word()]: {
								channel_id: faker.string.uuid(),
								creation_time: faker.lorem.words(),
								local_address: faker.lorem.words(),
								remote_address: faker.lorem.words(),
							},
						}))
						.reduce((acc, next) => Object.assign(acc, next), {}),
					creation_time: faker.lorem.words(),
					encryption: {
						cipher: faker.lorem.words(),
						degree: faker.lorem.words(),
					},
					gid: faker.number.int(),
					groupname: faker.person.fullName(),
					hostname: faker.person.fullName(),
					remote_machine: faker.lorem.words(),
					server_id: {
						pid: faker.string.uuid(),
						task_id: faker.string.uuid(),
						unique_id: faker.string.uuid(),
						vnn: faker.lorem.words(),
					},
					session_dialect: faker.lorem.words(),
					session_id: faker.string.uuid(),
					signing: {
						cipher: faker.lorem.words(),
						degree: faker.lorem.words(),
					},
					uid: faker.number.int(),
					username: faker.person.fullName(),
				},
			}))
			.reduce((acc, next) => Object.assign(acc, next), {}),
		smb_conf: faker.lorem.words(),
		tcons: [...new Array(5).keys()]
			.map((_) => ({
				[faker.lorem.word()]: {
					connected_at: faker.date.past(),
					device: faker.lorem.words(),
					encryption: {
						cipher: faker.lorem.words(),
						degree: faker.lorem.words(),
					},
					machine: faker.lorem.words(),
					server_id: {
						pid: faker.string.uuid(),
						task_id: faker.string.uuid(),
						unique_id: faker.string.uuid(),
						vnn: faker.lorem.words(),
					},
					service: faker.lorem.words(),
					session_id: faker.string.uuid(),
					share: faker.lorem.words(),
					signing: {
						cipher: faker.lorem.words(),
						degree: faker.lorem.words(),
					},
					tcon_id: faker.string.uuid(),
				},
			}))
			.reduce((acc, next) => Object.assign(acc, next), {}),
		timestamp: faker.lorem.words(),
		version: faker.lorem.words(),
	};
}

export function getGetApiSambaStatus4XxResponse() {
	return null;
}

export function getGetApiSambaStatusdefaultResponse() {
	return null;
}

export function getGetApiSettings200Response() {
	return {
		$schema: faker.internet.url(),
		allow_guest: faker.datatype.boolean(),
		allow_hosts: [
			...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
		].map((_) => faker.lorem.words()),
		bind_all_interfaces: faker.datatype.boolean(),
		compatibility_mode: faker.datatype.boolean(),
		export_stats_to_ha: faker.datatype.boolean(),
		hdidle_default_command_type: faker.helpers.arrayElement(["scsi", "ata"]),
		hdidle_default_idle_time: faker.number.int(),
		hdidle_default_power_condition: faker.number.int(),
		hdidle_enabled: faker.datatype.boolean(),
		hdidle_ignore_spin_down_detection: faker.datatype.boolean(),
		hostname: faker.person.fullName(),
		interfaces: [
			...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
		].map((_) => faker.lorem.words()),
		local_master: faker.datatype.boolean(),
		log_level: faker.lorem.words(),
		mountoptions: faker.helpers.arrayElement([
			[
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => faker.lorem.words()),
			null,
		]),
		multi_channel: faker.datatype.boolean(),
		smb_over_quic: faker.datatype.boolean(),
		telemetry_mode: faker.helpers.arrayElement([
			"Ask",
			"All",
			"Errors",
			"Disabled",
		]),
		workgroup: faker.lorem.words(),
	};
}

export function getGetApiSettings4XxResponse() {
	return null;
}

export function getGetApiSettingsdefaultResponse() {
	return null;
}

export function getPatchApiSettings200Response() {
	return {
		$schema: faker.internet.url(),
		allow_guest: faker.datatype.boolean(),
		allow_hosts: [
			...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
		].map((_) => faker.lorem.words()),
		bind_all_interfaces: faker.datatype.boolean(),
		compatibility_mode: faker.datatype.boolean(),
		export_stats_to_ha: faker.datatype.boolean(),
		hdidle_default_command_type: faker.helpers.arrayElement(["scsi", "ata"]),
		hdidle_default_idle_time: faker.number.int(),
		hdidle_default_power_condition: faker.number.int(),
		hdidle_enabled: faker.datatype.boolean(),
		hdidle_ignore_spin_down_detection: faker.datatype.boolean(),
		hostname: faker.person.fullName(),
		interfaces: [
			...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
		].map((_) => faker.lorem.words()),
		local_master: faker.datatype.boolean(),
		log_level: faker.lorem.words(),
		mountoptions: faker.helpers.arrayElement([
			[
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => faker.lorem.words()),
			null,
		]),
		multi_channel: faker.datatype.boolean(),
		smb_over_quic: faker.datatype.boolean(),
		telemetry_mode: faker.helpers.arrayElement([
			"Ask",
			"All",
			"Errors",
			"Disabled",
		]),
		workgroup: faker.lorem.words(),
	};
}

export function getPatchApiSettings4XxResponse() {
	return null;
}

export function getPatchApiSettingsdefaultResponse() {
	return null;
}

export function getPutApiSettings200Response() {
	return {
		$schema: faker.internet.url(),
		allow_guest: faker.datatype.boolean(),
		allow_hosts: [
			...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
		].map((_) => faker.lorem.words()),
		bind_all_interfaces: faker.datatype.boolean(),
		compatibility_mode: faker.datatype.boolean(),
		export_stats_to_ha: faker.datatype.boolean(),
		hdidle_default_command_type: faker.helpers.arrayElement(["scsi", "ata"]),
		hdidle_default_idle_time: faker.number.int(),
		hdidle_default_power_condition: faker.number.int(),
		hdidle_enabled: faker.datatype.boolean(),
		hdidle_ignore_spin_down_detection: faker.datatype.boolean(),
		hostname: faker.person.fullName(),
		interfaces: [
			...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
		].map((_) => faker.lorem.words()),
		local_master: faker.datatype.boolean(),
		log_level: faker.lorem.words(),
		mountoptions: faker.helpers.arrayElement([
			[
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => faker.lorem.words()),
			null,
		]),
		multi_channel: faker.datatype.boolean(),
		smb_over_quic: faker.datatype.boolean(),
		telemetry_mode: faker.helpers.arrayElement([
			"Ask",
			"All",
			"Errors",
			"Disabled",
		]),
		workgroup: faker.lorem.words(),
	};
}

export function getPutApiSettings4XxResponse() {
	return null;
}

export function getPutApiSettingsdefaultResponse() {
	return null;
}

export function getPostApiShare200Response() {
	return {
		$schema: faker.internet.url(),
		disabled: faker.datatype.boolean(),
		guest_ok: faker.datatype.boolean(),
		mount_point_data: {
			$schema: faker.internet.url(),
			custom_flags: [
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => ({
				description: faker.lorem.words(),
				name: faker.person.fullName(),
				needsValue: faker.datatype.boolean(),
				value: faker.lorem.words(),
				value_description: faker.lorem.words(),
				value_validation_regex: faker.lorem.words(),
			})),
			device_id: faker.string.uuid(),
			disk_label: faker.lorem.words(),
			disk_serial: faker.lorem.words(),
			disk_size: faker.number.int(),
			flags: [
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => ({
				description: faker.lorem.words(),
				name: faker.person.fullName(),
				needsValue: faker.datatype.boolean(),
				value: faker.lorem.words(),
				value_description: faker.lorem.words(),
				value_validation_regex: faker.lorem.words(),
			})),
			fstype: faker.lorem.words(),
			invalid: faker.datatype.boolean(),
			invalid_error: faker.lorem.words(),
			is_mounted: faker.datatype.boolean(),
			is_to_mount_at_startup: faker.datatype.boolean(),
			is_write_supported: faker.datatype.boolean(),
			path: faker.lorem.words(),
			refresh_version: faker.number.int(),
			root: faker.lorem.words(),
			share: null,
			time_machine_support: faker.helpers.arrayElement([
				"unsupported",
				"supported",
				"experimental",
				"unknown",
			]),
			type: faker.helpers.arrayElement(["HOST", "ADDON"]),
			warnings: faker.lorem.words(),
		},
		name: faker.person.fullName(),
		recycle_bin_enabled: faker.datatype.boolean(),
		ro_users: faker.helpers.arrayElement([
			[
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => null),
			null,
		]),
		status: {
			is_ha_mounted: faker.datatype.boolean(),
			is_valid: faker.datatype.boolean(),
		},
		timemachine: faker.datatype.boolean(),
		timemachine_max_size: faker.lorem.words(),
		usage: faker.helpers.arrayElement([
			"none",
			"backup",
			"media",
			"share",
			"internal",
		]),
		users: faker.helpers.arrayElement([
			[
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => null),
			null,
		]),
		veto_files: [
			...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
		].map((_) => faker.lorem.words()),
	};
}

export function getPostApiShare4XxResponse() {
	return null;
}

export function getPostApiSharedefaultResponse() {
	return null;
}

export function getDeleteApiShareByShareName4XxResponse() {
	return null;
}

export function getDeleteApiShareByShareNamedefaultResponse() {
	return null;
}

export function getGetApiShareByShareName200Response() {
	return {
		$schema: faker.internet.url(),
		disabled: faker.datatype.boolean(),
		guest_ok: faker.datatype.boolean(),
		mount_point_data: {
			$schema: faker.internet.url(),
			custom_flags: [
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => ({
				description: faker.lorem.words(),
				name: faker.person.fullName(),
				needsValue: faker.datatype.boolean(),
				value: faker.lorem.words(),
				value_description: faker.lorem.words(),
				value_validation_regex: faker.lorem.words(),
			})),
			device_id: faker.string.uuid(),
			disk_label: faker.lorem.words(),
			disk_serial: faker.lorem.words(),
			disk_size: faker.number.int(),
			flags: [
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => ({
				description: faker.lorem.words(),
				name: faker.person.fullName(),
				needsValue: faker.datatype.boolean(),
				value: faker.lorem.words(),
				value_description: faker.lorem.words(),
				value_validation_regex: faker.lorem.words(),
			})),
			fstype: faker.lorem.words(),
			invalid: faker.datatype.boolean(),
			invalid_error: faker.lorem.words(),
			is_mounted: faker.datatype.boolean(),
			is_to_mount_at_startup: faker.datatype.boolean(),
			is_write_supported: faker.datatype.boolean(),
			path: faker.lorem.words(),
			refresh_version: faker.number.int(),
			root: faker.lorem.words(),
			share: null,
			time_machine_support: faker.helpers.arrayElement([
				"unsupported",
				"supported",
				"experimental",
				"unknown",
			]),
			type: faker.helpers.arrayElement(["HOST", "ADDON"]),
			warnings: faker.lorem.words(),
		},
		name: faker.person.fullName(),
		recycle_bin_enabled: faker.datatype.boolean(),
		ro_users: faker.helpers.arrayElement([
			[
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => null),
			null,
		]),
		status: {
			is_ha_mounted: faker.datatype.boolean(),
			is_valid: faker.datatype.boolean(),
		},
		timemachine: faker.datatype.boolean(),
		timemachine_max_size: faker.lorem.words(),
		usage: faker.helpers.arrayElement([
			"none",
			"backup",
			"media",
			"share",
			"internal",
		]),
		users: faker.helpers.arrayElement([
			[
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => null),
			null,
		]),
		veto_files: [
			...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
		].map((_) => faker.lorem.words()),
	};
}

export function getGetApiShareByShareName4XxResponse() {
	return null;
}

export function getGetApiShareByShareNamedefaultResponse() {
	return null;
}

export function getPatchApiShareByShareName200Response() {
	return {
		$schema: faker.internet.url(),
		disabled: faker.datatype.boolean(),
		guest_ok: faker.datatype.boolean(),
		mount_point_data: {
			$schema: faker.internet.url(),
			custom_flags: [
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => ({
				description: faker.lorem.words(),
				name: faker.person.fullName(),
				needsValue: faker.datatype.boolean(),
				value: faker.lorem.words(),
				value_description: faker.lorem.words(),
				value_validation_regex: faker.lorem.words(),
			})),
			device_id: faker.string.uuid(),
			disk_label: faker.lorem.words(),
			disk_serial: faker.lorem.words(),
			disk_size: faker.number.int(),
			flags: [
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => ({
				description: faker.lorem.words(),
				name: faker.person.fullName(),
				needsValue: faker.datatype.boolean(),
				value: faker.lorem.words(),
				value_description: faker.lorem.words(),
				value_validation_regex: faker.lorem.words(),
			})),
			fstype: faker.lorem.words(),
			invalid: faker.datatype.boolean(),
			invalid_error: faker.lorem.words(),
			is_mounted: faker.datatype.boolean(),
			is_to_mount_at_startup: faker.datatype.boolean(),
			is_write_supported: faker.datatype.boolean(),
			path: faker.lorem.words(),
			refresh_version: faker.number.int(),
			root: faker.lorem.words(),
			share: null,
			time_machine_support: faker.helpers.arrayElement([
				"unsupported",
				"supported",
				"experimental",
				"unknown",
			]),
			type: faker.helpers.arrayElement(["HOST", "ADDON"]),
			warnings: faker.lorem.words(),
		},
		name: faker.person.fullName(),
		recycle_bin_enabled: faker.datatype.boolean(),
		ro_users: faker.helpers.arrayElement([
			[
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => null),
			null,
		]),
		status: {
			is_ha_mounted: faker.datatype.boolean(),
			is_valid: faker.datatype.boolean(),
		},
		timemachine: faker.datatype.boolean(),
		timemachine_max_size: faker.lorem.words(),
		usage: faker.helpers.arrayElement([
			"none",
			"backup",
			"media",
			"share",
			"internal",
		]),
		users: faker.helpers.arrayElement([
			[
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => null),
			null,
		]),
		veto_files: [
			...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
		].map((_) => faker.lorem.words()),
	};
}

export function getPatchApiShareByShareName4XxResponse() {
	return null;
}

export function getPatchApiShareByShareNamedefaultResponse() {
	return null;
}

export function getPutApiShareByShareName200Response() {
	return {
		$schema: faker.internet.url(),
		disabled: faker.datatype.boolean(),
		guest_ok: faker.datatype.boolean(),
		mount_point_data: {
			$schema: faker.internet.url(),
			custom_flags: [
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => ({
				description: faker.lorem.words(),
				name: faker.person.fullName(),
				needsValue: faker.datatype.boolean(),
				value: faker.lorem.words(),
				value_description: faker.lorem.words(),
				value_validation_regex: faker.lorem.words(),
			})),
			device_id: faker.string.uuid(),
			disk_label: faker.lorem.words(),
			disk_serial: faker.lorem.words(),
			disk_size: faker.number.int(),
			flags: [
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => ({
				description: faker.lorem.words(),
				name: faker.person.fullName(),
				needsValue: faker.datatype.boolean(),
				value: faker.lorem.words(),
				value_description: faker.lorem.words(),
				value_validation_regex: faker.lorem.words(),
			})),
			fstype: faker.lorem.words(),
			invalid: faker.datatype.boolean(),
			invalid_error: faker.lorem.words(),
			is_mounted: faker.datatype.boolean(),
			is_to_mount_at_startup: faker.datatype.boolean(),
			is_write_supported: faker.datatype.boolean(),
			path: faker.lorem.words(),
			refresh_version: faker.number.int(),
			root: faker.lorem.words(),
			share: null,
			time_machine_support: faker.helpers.arrayElement([
				"unsupported",
				"supported",
				"experimental",
				"unknown",
			]),
			type: faker.helpers.arrayElement(["HOST", "ADDON"]),
			warnings: faker.lorem.words(),
		},
		name: faker.person.fullName(),
		recycle_bin_enabled: faker.datatype.boolean(),
		ro_users: faker.helpers.arrayElement([
			[
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => null),
			null,
		]),
		status: {
			is_ha_mounted: faker.datatype.boolean(),
			is_valid: faker.datatype.boolean(),
		},
		timemachine: faker.datatype.boolean(),
		timemachine_max_size: faker.lorem.words(),
		usage: faker.helpers.arrayElement([
			"none",
			"backup",
			"media",
			"share",
			"internal",
		]),
		users: faker.helpers.arrayElement([
			[
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => null),
			null,
		]),
		veto_files: [
			...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
		].map((_) => faker.lorem.words()),
	};
}

export function getPutApiShareByShareName4XxResponse() {
	return null;
}

export function getPutApiShareByShareNamedefaultResponse() {
	return null;
}

export function getPutApiShareByShareNameDisable200Response() {
	return {
		$schema: faker.internet.url(),
		disabled: faker.datatype.boolean(),
		guest_ok: faker.datatype.boolean(),
		mount_point_data: {
			$schema: faker.internet.url(),
			custom_flags: [
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => ({
				description: faker.lorem.words(),
				name: faker.person.fullName(),
				needsValue: faker.datatype.boolean(),
				value: faker.lorem.words(),
				value_description: faker.lorem.words(),
				value_validation_regex: faker.lorem.words(),
			})),
			device_id: faker.string.uuid(),
			disk_label: faker.lorem.words(),
			disk_serial: faker.lorem.words(),
			disk_size: faker.number.int(),
			flags: [
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => ({
				description: faker.lorem.words(),
				name: faker.person.fullName(),
				needsValue: faker.datatype.boolean(),
				value: faker.lorem.words(),
				value_description: faker.lorem.words(),
				value_validation_regex: faker.lorem.words(),
			})),
			fstype: faker.lorem.words(),
			invalid: faker.datatype.boolean(),
			invalid_error: faker.lorem.words(),
			is_mounted: faker.datatype.boolean(),
			is_to_mount_at_startup: faker.datatype.boolean(),
			is_write_supported: faker.datatype.boolean(),
			path: faker.lorem.words(),
			refresh_version: faker.number.int(),
			root: faker.lorem.words(),
			share: null,
			time_machine_support: faker.helpers.arrayElement([
				"unsupported",
				"supported",
				"experimental",
				"unknown",
			]),
			type: faker.helpers.arrayElement(["HOST", "ADDON"]),
			warnings: faker.lorem.words(),
		},
		name: faker.person.fullName(),
		recycle_bin_enabled: faker.datatype.boolean(),
		ro_users: faker.helpers.arrayElement([
			[
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => null),
			null,
		]),
		status: {
			is_ha_mounted: faker.datatype.boolean(),
			is_valid: faker.datatype.boolean(),
		},
		timemachine: faker.datatype.boolean(),
		timemachine_max_size: faker.lorem.words(),
		usage: faker.helpers.arrayElement([
			"none",
			"backup",
			"media",
			"share",
			"internal",
		]),
		users: faker.helpers.arrayElement([
			[
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => null),
			null,
		]),
		veto_files: [
			...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
		].map((_) => faker.lorem.words()),
	};
}

export function getPutApiShareByShareNameDisable4XxResponse() {
	return null;
}

export function getPutApiShareByShareNameDisabledefaultResponse() {
	return null;
}

export function getPutApiShareByShareNameEnable200Response() {
	return {
		$schema: faker.internet.url(),
		disabled: faker.datatype.boolean(),
		guest_ok: faker.datatype.boolean(),
		mount_point_data: {
			$schema: faker.internet.url(),
			custom_flags: [
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => ({
				description: faker.lorem.words(),
				name: faker.person.fullName(),
				needsValue: faker.datatype.boolean(),
				value: faker.lorem.words(),
				value_description: faker.lorem.words(),
				value_validation_regex: faker.lorem.words(),
			})),
			device_id: faker.string.uuid(),
			disk_label: faker.lorem.words(),
			disk_serial: faker.lorem.words(),
			disk_size: faker.number.int(),
			flags: [
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => ({
				description: faker.lorem.words(),
				name: faker.person.fullName(),
				needsValue: faker.datatype.boolean(),
				value: faker.lorem.words(),
				value_description: faker.lorem.words(),
				value_validation_regex: faker.lorem.words(),
			})),
			fstype: faker.lorem.words(),
			invalid: faker.datatype.boolean(),
			invalid_error: faker.lorem.words(),
			is_mounted: faker.datatype.boolean(),
			is_to_mount_at_startup: faker.datatype.boolean(),
			is_write_supported: faker.datatype.boolean(),
			path: faker.lorem.words(),
			refresh_version: faker.number.int(),
			root: faker.lorem.words(),
			share: null,
			time_machine_support: faker.helpers.arrayElement([
				"unsupported",
				"supported",
				"experimental",
				"unknown",
			]),
			type: faker.helpers.arrayElement(["HOST", "ADDON"]),
			warnings: faker.lorem.words(),
		},
		name: faker.person.fullName(),
		recycle_bin_enabled: faker.datatype.boolean(),
		ro_users: faker.helpers.arrayElement([
			[
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => null),
			null,
		]),
		status: {
			is_ha_mounted: faker.datatype.boolean(),
			is_valid: faker.datatype.boolean(),
		},
		timemachine: faker.datatype.boolean(),
		timemachine_max_size: faker.lorem.words(),
		usage: faker.helpers.arrayElement([
			"none",
			"backup",
			"media",
			"share",
			"internal",
		]),
		users: faker.helpers.arrayElement([
			[
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => null),
			null,
		]),
		veto_files: [
			...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
		].map((_) => faker.lorem.words()),
	};
}

export function getPutApiShareByShareNameEnable4XxResponse() {
	return null;
}

export function getPutApiShareByShareNameEnabledefaultResponse() {
	return null;
}

export function getListApiShares200Response() {
	return faker.helpers.arrayElement([
		[
			...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
		].map((_) => null),
		null,
	]);
}

export function getListApiShares4XxResponse() {
	return null;
}

export function getListApiSharesdefaultResponse() {
	return null;
}

export function getSse200Response() {
	return null;
}

export function getSse4XxResponse() {
	return null;
}

export function getSsedefaultResponse() {
	return null;
}

export function getGetApiStatus200Response() {
	return faker.datatype.boolean();
}

export function getGetApiStatus4XxResponse() {
	return null;
}

export function getGetApiStatusdefaultResponse() {
	return null;
}

export function getGetApiTelemetryInternetConnection200Response() {
	return faker.datatype.boolean();
}

export function getGetApiTelemetryInternetConnection4XxResponse() {
	return null;
}

export function getGetApiTelemetryInternetConnectiondefaultResponse() {
	return null;
}

export function getListApiTelemetryModes200Response() {
	return faker.helpers.arrayElement([
		[
			...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
		].map((_) => faker.lorem.words()),
		null,
	]);
}

export function getListApiTelemetryModes4XxResponse() {
	return null;
}

export function getListApiTelemetryModesdefaultResponse() {
	return null;
}

export function getGetApiUpdate200Response() {
	return {
		$schema: faker.internet.url(),
		arch_asset: {
			browser_download_url: faker.internet.url(),
			digest: faker.lorem.words(),
			id: faker.number.int(),
			name: faker.person.fullName(),
			size: faker.number.int(),
		},
		last_release: faker.lorem.words(),
	};
}

export function getGetApiUpdate4XxResponse() {
	return null;
}

export function getGetApiUpdatedefaultResponse() {
	return null;
}

export function getPutApiUpdate200Response() {
	return {
		$schema: faker.internet.url(),
		error_message: faker.lorem.words(),
		progress: faker.number.int(),
		release_asset: {
			$schema: faker.internet.url(),
			arch_asset: {
				browser_download_url: faker.internet.url(),
				digest: faker.lorem.words(),
				id: faker.number.int(),
				name: faker.person.fullName(),
				size: faker.number.int(),
			},
			last_release: faker.lorem.words(),
		},
		update_process_state: faker.helpers.arrayElement([
			"Idle",
			"Checking",
			"NoUpgrde",
			"UpgradeAvailable",
			"Downloading",
			"DownloadComplete",
			"Extracting",
			"ExtractComplete",
			"Installing",
			"NeedRestart",
			"Error",
		]),
	};
}

export function getPutApiUpdate4XxResponse() {
	return null;
}

export function getPutApiUpdatedefaultResponse() {
	return null;
}

export function getListApiUpdateChannels200Response() {
	return faker.helpers.arrayElement([
		[
			...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
		].map((_) => faker.lorem.words()),
		null,
	]);
}

export function getListApiUpdateChannels4XxResponse() {
	return null;
}

export function getListApiUpdateChannelsdefaultResponse() {
	return null;
}

export function getPostApiUser200Response() {
	return {
		$schema: faker.internet.url(),
		is_admin: faker.datatype.boolean(),
		password: faker.lorem.words(),
		ro_shares: faker.helpers.arrayElement([
			[
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => faker.lorem.words()),
			null,
		]),
		rw_shares: faker.helpers.arrayElement([
			[
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => faker.lorem.words()),
			null,
		]),
		username: faker.person.fullName(),
	};
}

export function getPostApiUser4XxResponse() {
	return null;
}

export function getPostApiUserdefaultResponse() {
	return null;
}

export function getDeleteApiUserByUsername4XxResponse() {
	return null;
}

export function getDeleteApiUserByUsernamedefaultResponse() {
	return null;
}

export function getPutApiUserByUsername200Response() {
	return {
		$schema: faker.internet.url(),
		is_admin: faker.datatype.boolean(),
		password: faker.lorem.words(),
		ro_shares: faker.helpers.arrayElement([
			[
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => faker.lorem.words()),
			null,
		]),
		rw_shares: faker.helpers.arrayElement([
			[
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => faker.lorem.words()),
			null,
		]),
		username: faker.person.fullName(),
	};
}

export function getPutApiUserByUsername4XxResponse() {
	return null;
}

export function getPutApiUserByUsernamedefaultResponse() {
	return null;
}

export function getPutApiUseradmin200Response() {
	return {
		$schema: faker.internet.url(),
		is_admin: faker.datatype.boolean(),
		password: faker.lorem.words(),
		ro_shares: faker.helpers.arrayElement([
			[
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => faker.lorem.words()),
			null,
		]),
		rw_shares: faker.helpers.arrayElement([
			[
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => faker.lorem.words()),
			null,
		]),
		username: faker.person.fullName(),
	};
}

export function getPutApiUseradmin4XxResponse() {
	return null;
}

export function getPutApiUseradmindefaultResponse() {
	return null;
}

export function getListApiUsers200Response() {
	return faker.helpers.arrayElement([
		[
			...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
		].map((_) => null),
		null,
	]);
}

export function getListApiUsers4XxResponse() {
	return null;
}

export function getListApiUsersdefaultResponse() {
	return null;
}

export function getDeleteApiVolume4XxResponse() {
	return null;
}

export function getDeleteApiVolumedefaultResponse() {
	return null;
}

export function getPostApiVolumeMount200Response() {
	return {
		$schema: faker.internet.url(),
		custom_flags: [
			...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
		].map((_) => ({
			description: faker.lorem.words(),
			name: faker.person.fullName(),
			needsValue: faker.datatype.boolean(),
			value: faker.lorem.words(),
			value_description: faker.lorem.words(),
			value_validation_regex: faker.lorem.words(),
		})),
		device_id: faker.string.uuid(),
		disk_label: faker.lorem.words(),
		disk_serial: faker.lorem.words(),
		disk_size: faker.number.int(),
		flags: [
			...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
		].map((_) => ({
			description: faker.lorem.words(),
			name: faker.person.fullName(),
			needsValue: faker.datatype.boolean(),
			value: faker.lorem.words(),
			value_description: faker.lorem.words(),
			value_validation_regex: faker.lorem.words(),
		})),
		fstype: faker.lorem.words(),
		invalid: faker.datatype.boolean(),
		invalid_error: faker.lorem.words(),
		is_mounted: faker.datatype.boolean(),
		is_to_mount_at_startup: faker.datatype.boolean(),
		is_write_supported: faker.datatype.boolean(),
		path: faker.lorem.words(),
		refresh_version: faker.number.int(),
		root: faker.lorem.words(),
		share: {
			$schema: faker.internet.url(),
			disabled: faker.datatype.boolean(),
			guest_ok: faker.datatype.boolean(),
			mount_point_data: null,
			name: faker.person.fullName(),
			recycle_bin_enabled: faker.datatype.boolean(),
			ro_users: faker.helpers.arrayElement([
				[
					...new Array(
						faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
					).keys(),
				].map((_) => null),
				null,
			]),
			status: {
				is_ha_mounted: faker.datatype.boolean(),
				is_valid: faker.datatype.boolean(),
			},
			timemachine: faker.datatype.boolean(),
			timemachine_max_size: faker.lorem.words(),
			usage: faker.helpers.arrayElement([
				"none",
				"backup",
				"media",
				"share",
				"internal",
			]),
			users: faker.helpers.arrayElement([
				[
					...new Array(
						faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
					).keys(),
				].map((_) => null),
				null,
			]),
			veto_files: [
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => faker.lorem.words()),
		},
		time_machine_support: faker.helpers.arrayElement([
			"unsupported",
			"supported",
			"experimental",
			"unknown",
		]),
		type: faker.helpers.arrayElement(["HOST", "ADDON"]),
		warnings: faker.lorem.words(),
	};
}

export function getPostApiVolumeMount4XxResponse() {
	return null;
}

export function getPostApiVolumeMountdefaultResponse() {
	return null;
}

export function getPatchApiVolumeSettings200Response() {
	return {
		$schema: faker.internet.url(),
		custom_flags: [
			...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
		].map((_) => ({
			description: faker.lorem.words(),
			name: faker.person.fullName(),
			needsValue: faker.datatype.boolean(),
			value: faker.lorem.words(),
			value_description: faker.lorem.words(),
			value_validation_regex: faker.lorem.words(),
		})),
		device_id: faker.string.uuid(),
		disk_label: faker.lorem.words(),
		disk_serial: faker.lorem.words(),
		disk_size: faker.number.int(),
		flags: [
			...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
		].map((_) => ({
			description: faker.lorem.words(),
			name: faker.person.fullName(),
			needsValue: faker.datatype.boolean(),
			value: faker.lorem.words(),
			value_description: faker.lorem.words(),
			value_validation_regex: faker.lorem.words(),
		})),
		fstype: faker.lorem.words(),
		invalid: faker.datatype.boolean(),
		invalid_error: faker.lorem.words(),
		is_mounted: faker.datatype.boolean(),
		is_to_mount_at_startup: faker.datatype.boolean(),
		is_write_supported: faker.datatype.boolean(),
		path: faker.lorem.words(),
		refresh_version: faker.number.int(),
		root: faker.lorem.words(),
		share: {
			$schema: faker.internet.url(),
			disabled: faker.datatype.boolean(),
			guest_ok: faker.datatype.boolean(),
			mount_point_data: null,
			name: faker.person.fullName(),
			recycle_bin_enabled: faker.datatype.boolean(),
			ro_users: faker.helpers.arrayElement([
				[
					...new Array(
						faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
					).keys(),
				].map((_) => null),
				null,
			]),
			status: {
				is_ha_mounted: faker.datatype.boolean(),
				is_valid: faker.datatype.boolean(),
			},
			timemachine: faker.datatype.boolean(),
			timemachine_max_size: faker.lorem.words(),
			usage: faker.helpers.arrayElement([
				"none",
				"backup",
				"media",
				"share",
				"internal",
			]),
			users: faker.helpers.arrayElement([
				[
					...new Array(
						faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
					).keys(),
				].map((_) => null),
				null,
			]),
			veto_files: [
				...new Array(
					faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
				).keys(),
			].map((_) => faker.lorem.words()),
		},
		time_machine_support: faker.helpers.arrayElement([
			"unsupported",
			"supported",
			"experimental",
			"unknown",
		]),
		type: faker.helpers.arrayElement(["HOST", "ADDON"]),
		warnings: faker.lorem.words(),
	};
}

export function getPatchApiVolumeSettings4XxResponse() {
	return null;
}

export function getPatchApiVolumeSettingsdefaultResponse() {
	return null;
}

export function getListApiVolumes200Response() {
	return faker.helpers.arrayElement([
		[
			...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
		].map((_) => null),
		null,
	]);
}

export function getListApiVolumes4XxResponse() {
	return null;
}

export function getListApiVolumesdefaultResponse() {
	return null;
}
