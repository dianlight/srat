// DO NOT EDIT.
// code generated by goenums v0.4.4.
//
// github.com/zarldev/goenums
//
// using the command:
// goenums -l webevent_type.go

package dto

import (
	"bytes"
	"database/sql/driver"
	"fmt"
	"math"

	"golang.org/x/exp/constraints"
)

// WebEventType is a type that represents a single enum value.
// It combines the core information about the enum constant and it's defined fields.
type WebEventType struct {
	webEventType
}

// webEventTypesContainer is the container for all enum values.
// It is private and should not be used directly use the public methods on the WebEventType type.
type webEventTypesContainer struct {
	EVENTHELLO           WebEventType
	EVENTUPDATING        WebEventType
	EVENTVOLUMES         WebEventType
	EVENTHEARTBEAT       WebEventType
	EVENTSHARES          WebEventType
	EVENTDIRTYTRACKER    WebEventType
	EVENTSMARTTESTSTATUS WebEventType
}

// WebEventTypes is a main entry point using the WebEventType type.
// It it a container for all enum values and provides a convenient way to access all enum values and perform
// operations, with convenience methods for common use cases.
var WebEventTypes = webEventTypesContainer{
	EVENTHELLO: WebEventType{
		webEventType: eventHello,
	},
	EVENTUPDATING: WebEventType{
		webEventType: eventUpdating,
	},
	EVENTVOLUMES: WebEventType{
		webEventType: eventVolumes,
	},
	EVENTHEARTBEAT: WebEventType{
		webEventType: eventHeartbeat,
	},
	EVENTSHARES: WebEventType{
		webEventType: eventShares,
	},
	EVENTDIRTYTRACKER: WebEventType{
		webEventType: eventDirtyTracker,
	},
	EVENTSMARTTESTSTATUS: WebEventType{
		webEventType: eventSmartTestStatus,
	},
}

// invalidWebEventType is an invalid sentinel value for WebEventType
var invalidWebEventType = WebEventType{
	webEventType: -1,
}

// allSlice returns a slice of all enum values.
// This method is useful for iterating over all enum values in a loop.
func (w webEventTypesContainer) allSlice() []WebEventType {
	return []WebEventType{
		WebEventTypes.EVENTHELLO,
		WebEventTypes.EVENTUPDATING,
		WebEventTypes.EVENTVOLUMES,
		WebEventTypes.EVENTHEARTBEAT,
		WebEventTypes.EVENTSHARES,
		WebEventTypes.EVENTDIRTYTRACKER,
		WebEventTypes.EVENTSMARTTESTSTATUS,
	}
}

// All returns a slice of all enum values.
// This method is useful for iterating over all enum values in a loop.
func (w webEventTypesContainer) All() []WebEventType {
	return w.allSlice()
}

// ParseWebEventType parses the input value into an enum value.
// It returns the parsed enum value or an error if the input is invalid.
// It is a convenience function that can be used to parse enum values from
// various input types, such as strings, byte slices, or other enum types.
func ParseWebEventType(input any) (WebEventType, error) {
	switch v := input.(type) {
	case WebEventType:
		return v, nil
	case string:
		if result := stringToWebEventType(v); result != nil {
			return *result, nil
		}
	case fmt.Stringer:
		if result := stringToWebEventType(v.String()); result != nil {
			return *result, nil
		}
	case []byte:
		if result := stringToWebEventType(string(v)); result != nil {
			return *result, nil
		}
	case int:
		if result := numberToWebEventType(v); result != nil {
			return *result, nil
		}
	case int8:
		if result := numberToWebEventType(v); result != nil {
			return *result, nil
		}
	case int16:
		if result := numberToWebEventType(v); result != nil {
			return *result, nil
		}
	case int32:
		if result := numberToWebEventType(v); result != nil {
			return *result, nil
		}
	case int64:
		if result := numberToWebEventType(v); result != nil {
			return *result, nil
		}
	case uint:
		if result := numberToWebEventType(v); result != nil {
			return *result, nil
		}
	case uint8:
		if result := numberToWebEventType(v); result != nil {
			return *result, nil
		}
	case uint16:
		if result := numberToWebEventType(v); result != nil {
			return *result, nil
		}
	case uint32:
		if result := numberToWebEventType(v); result != nil {
			return *result, nil
		}
	case uint64:
		if result := numberToWebEventType(v); result != nil {
			return *result, nil
		}
	case float32:
		if result := numberToWebEventType(v); result != nil {
			return *result, nil
		}
	case float64:
		if result := numberToWebEventType(v); result != nil {
			return *result, nil
		}
	default:
		return invalidWebEventType, fmt.Errorf("invalid type %T", input)
	}
	return invalidWebEventType, nil
}

// webEventTypesNameMap is a map of enum values to their WebEventType representation
// It is used to convert string representations of enum values into their WebEventType representation.
var webEventTypesNameMap = map[string]WebEventType{
	"hello":              WebEventTypes.EVENTHELLO,
	"updating":           WebEventTypes.EVENTUPDATING,
	"volumes":            WebEventTypes.EVENTVOLUMES,
	"heartbeat":          WebEventTypes.EVENTHEARTBEAT,
	"shares":             WebEventTypes.EVENTSHARES,
	"dirty_data_tracker": WebEventTypes.EVENTDIRTYTRACKER,
	"smart_test_status":  WebEventTypes.EVENTSMARTTESTSTATUS,
}

// stringToWebEventType converts a string representation of an enum value into its WebEventType representation
// It returns a pointer to the WebEventType representation of the enum value if the string is valid
// Otherwise, it returns nil
func stringToWebEventType(s string) *WebEventType {
	if t, ok := webEventTypesNameMap[s]; ok {
		return &t
	}
	return nil
}

// numberToWebEventType converts a numeric value to a WebEventType
// It returns a pointer to the WebEventType representation of the enum value if the numeric value is valid
// Otherwise, it returns nil
func numberToWebEventType[T constraints.Integer | constraints.Float](num T) *WebEventType {
	f := float64(num)
	if math.Floor(f) != f {
		return nil
	}
	i := int(f)
	if i <= 0 || i > len(WebEventTypes.allSlice()) {
		return nil
	}
	result := WebEventTypes.allSlice()[i-1]
	if !result.IsValid() {
		return nil
	}
	return &result
}

// ExhaustiveWebEventTypes iterates over all enum values and calls the provided function for each value.
// This function is useful for performing operations on all valid enum values in a loop.
func ExhaustiveWebEventTypes(f func(WebEventType)) {
	for _, p := range WebEventTypes.allSlice() {
		f(p)
	}
}

// validWebEventTypes is a map of enum values to their validity
var validWebEventTypes = map[WebEventType]bool{
	WebEventTypes.EVENTHELLO:           true,
	WebEventTypes.EVENTUPDATING:        true,
	WebEventTypes.EVENTVOLUMES:         true,
	WebEventTypes.EVENTHEARTBEAT:       true,
	WebEventTypes.EVENTSHARES:          true,
	WebEventTypes.EVENTDIRTYTRACKER:    true,
	WebEventTypes.EVENTSMARTTESTSTATUS: true,
}

// IsValid checks whether the WebEventTypes value is valid.
// A valid value is one that is defined in the original enum and not marked as invalid.
func (w WebEventType) IsValid() bool {
	return validWebEventTypes[w]
}

// MarshalJSON implements the json.Marshaler interface for WebEventType.
// It returns the JSON representation of the enum value as a byte slice.
func (w WebEventType) MarshalJSON() ([]byte, error) {
	return []byte("\"" + w.String() + "\""), nil
}

// UnmarshalJSON implements the json.Unmarshaler interface for WebEventType.
// It parses the JSON representation of the enum value from the byte slice.
// It returns an error if the input is not a valid JSON representation.
func (w *WebEventType) UnmarshalJSON(by []byte) error {
	by = bytes.Trim(bytes.Trim(by, "\""), "\"")
	neww, err := ParseWebEventType(by)
	if err != nil {
		return err
	}
	*w = neww
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for WebEventType.
// It returns the string representation of the enum value as a byte slice
func (w WebEventType) MarshalText() ([]byte, error) {
	return []byte("\"" + w.String() + "\""), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for WebEventType.
// It parses the string representation of the enum value from the byte slice.
// It returns an error if the byte slice does not contain a valid enum value.
func (w *WebEventType) UnmarshalText(by []byte) error {
	neww, err := ParseWebEventType(by)
	if err != nil {
		return err
	}
	*w = neww
	return nil
}

// Scan implements the database/sql.Scanner interface for WebEventType.
// It parses the string representation of the enum value from the database row.
// It returns an error if the row does not contain a valid enum value.
func (w *WebEventType) Scan(value any) error {
	neww, err := ParseWebEventType(value)
	if err != nil {
		return err
	}
	*w = neww
	return nil
}

// Value implements the database/sql/driver.Valuer interface for WebEventType.
// It returns the string representation of the enum value.
func (w WebEventType) Value() (driver.Value, error) {
	return w.String(), nil
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for WebEventType.
// It returns the binary representation of the enum value as a byte slice.
func (w WebEventType) MarshalBinary() ([]byte, error) {
	return []byte("\"" + w.String() + "\""), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for WebEventType.
// It parses the binary representation of the enum value from the byte slice.
// It returns an error if the byte slice does not contain a valid enum value.
func (w *WebEventType) UnmarshalBinary(by []byte) error {
	neww, err := ParseWebEventType(by)
	if err != nil {
		return err
	}
	*w = neww
	return nil
}

// MarshalYAML implements the yaml.Marshaler interface for WebEventType.
// It returns the string representation of the enum value.
func (w WebEventType) MarshalYAML() ([]byte, error) {
	return []byte(w.String()), nil
}

// UnmarshalYAML implements the yaml.Unmarshaler interface for Planet.
// It parses the byte slice representation of the enum value and returns an error
// if the YAML byte slice does not contain a valid enum value.
func (w *WebEventType) UnmarshalYAML(by []byte) error {
	neww, err := ParseWebEventType(by)
	if err != nil {
		return err
	}
	*w = neww
	return nil
}

// webeventtypeNames is a constant string slice containing all enum values cononical absolute names
const webeventtypeNames = "helloupdatingvolumesheartbeatsharesdirty_data_trackersmart_test_status"

// webeventtypeNamesMap is a map of enum values to their canonical absolute
// name positions within the webeventtypeNames string slice
var webeventtypeNamesMap = map[WebEventType]string{
	WebEventTypes.EVENTHELLO:           webeventtypeNames[0:5],
	WebEventTypes.EVENTUPDATING:        webeventtypeNames[5:13],
	WebEventTypes.EVENTVOLUMES:         webeventtypeNames[13:20],
	WebEventTypes.EVENTHEARTBEAT:       webeventtypeNames[20:29],
	WebEventTypes.EVENTSHARES:          webeventtypeNames[29:35],
	WebEventTypes.EVENTDIRTYTRACKER:    webeventtypeNames[35:53],
	WebEventTypes.EVENTSMARTTESTSTATUS: webeventtypeNames[53:70],
}

// String implements the Stringer interface.
// It returns the canonical absolute name of the enum value.
func (w WebEventType) String() string {
	if str, ok := webeventtypeNamesMap[w]; ok {
		return str
	}
	return fmt.Sprintf("webeventtype(%d)", w.webEventType)
}

// Compile-time check that all enum values are valid.
// This function is used to ensure that all enum values are defined and valid.
// It is called by the compiler to verify that the enum values are valid.
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the goenums command to generate them again.
	// Does not identify newly added constant values unless order changes
	var x [7]struct{}
	_ = x[eventHello]
	_ = x[eventUpdating-1]
	_ = x[eventVolumes-2]
	_ = x[eventHeartbeat-3]
	_ = x[eventShares-4]
	_ = x[eventDirtyTracker-5]
	_ = x[eventSmartTestStatus-6]
}
