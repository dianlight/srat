// DO NOT EDIT.
// code generated by goenums v0.4.4.
//
// github.com/zarldev/goenums
//
// using the command:
// goenums issue_problem_type.go

package dto

import (
	"bytes"
	"database/sql/driver"
	"fmt"
	"iter"
	"math"

	"golang.org/x/exp/constraints"
)

// ProblemType is a type that represents a single enum value.
// It combines the core information about the enum constant and it's defined fields.
type ProblemType struct {
	problemType
	Description   string
	IssueTitle    string
	RepositoryUrl string
	Template      string
}

// problemTypesContainer is the container for all enum values.
// It is private and should not be used directly use the public methods on the ProblemType type.
type problemTypesContainer struct {
	PROBLEMTYPEFRONTENDUI    ProblemType
	PROBLEMTYPEHAINTEGRATION ProblemType
	PROBLEMTYPEADDON         ProblemType
	PROBLEMTYPESAMBA         ProblemType
}

// ProblemTypes is a main entry point using the ProblemType type.
// It it a container for all enum values and provides a convenient way to access all enum values and perform
// operations, with convenience methods for common use cases.
var ProblemTypes = problemTypesContainer{
	PROBLEMTYPEFRONTENDUI: ProblemType{
		problemType:   problemTypeFrontendUI,
		Description:   "Frontend UI",
		IssueTitle:    "[UI]",
		RepositoryUrl: "https://github.com/dianlight/srat",
		Template:      "bug_report.yaml",
	},
	PROBLEMTYPEHAINTEGRATION: ProblemType{
		problemType:   problemTypeHAIntegration,
		Description:   "HA Integration",
		IssueTitle:    "[HA Integration]",
		RepositoryUrl: "https://github.com/dianlight/srat",
		Template:      "bug_report.yaml",
	},
	PROBLEMTYPEADDON: ProblemType{
		problemType:   problemTypeAddon,
		Description:   "Addon",
		IssueTitle:    "[SambaNas2]",
		RepositoryUrl: "https://github.com/dianlight/hassio-addons",
		Template:      "BUG-REPORT.yml",
	},
	PROBLEMTYPESAMBA: ProblemType{
		problemType:   problemTypeSamba,
		Description:   "Samba",
		IssueTitle:    "[Samba]",
		RepositoryUrl: "https://github.com/dianlight/srat",
		Template:      "bug_report.yaml",
	},
}

// invalidProblemType is an invalid sentinel value for ProblemType
var invalidProblemType = ProblemType{
	problemType: -1,
}

// allSlice returns a slice of all enum values.
// This method is useful for iterating over all enum values in a loop.
func (p problemTypesContainer) allSlice() []ProblemType {
	return []ProblemType{
		ProblemTypes.PROBLEMTYPEFRONTENDUI,
		ProblemTypes.PROBLEMTYPEHAINTEGRATION,
		ProblemTypes.PROBLEMTYPEADDON,
		ProblemTypes.PROBLEMTYPESAMBA,
	}
}

// All returns an iterator over all enum values.
// This method is useful for iterating over all enum values in a loop.
func (p problemTypesContainer) All() iter.Seq[ProblemType] {
	return func(yield func(ProblemType) bool) {
		for _, v := range p.allSlice() {
			if !yield(v) {
				return
			}
		}
	}
}

// ParseProblemType parses the input value into an enum value.
// It returns the parsed enum value or an error if the input is invalid.
// It is a convenience function that can be used to parse enum values from
// various input types, such as strings, byte slices, or other enum types.
func ParseProblemType(input any) (ProblemType, error) {
	switch v := input.(type) {
	case ProblemType:
		return v, nil
	case string:
		if result := stringToProblemType(v); result != nil {
			return *result, nil
		}
	case fmt.Stringer:
		if result := stringToProblemType(v.String()); result != nil {
			return *result, nil
		}
	case []byte:
		if result := stringToProblemType(string(v)); result != nil {
			return *result, nil
		}
	case int:
		if result := numberToProblemType(v); result != nil {
			return *result, nil
		}
	case int8:
		if result := numberToProblemType(v); result != nil {
			return *result, nil
		}
	case int16:
		if result := numberToProblemType(v); result != nil {
			return *result, nil
		}
	case int32:
		if result := numberToProblemType(v); result != nil {
			return *result, nil
		}
	case int64:
		if result := numberToProblemType(v); result != nil {
			return *result, nil
		}
	case uint:
		if result := numberToProblemType(v); result != nil {
			return *result, nil
		}
	case uint8:
		if result := numberToProblemType(v); result != nil {
			return *result, nil
		}
	case uint16:
		if result := numberToProblemType(v); result != nil {
			return *result, nil
		}
	case uint32:
		if result := numberToProblemType(v); result != nil {
			return *result, nil
		}
	case uint64:
		if result := numberToProblemType(v); result != nil {
			return *result, nil
		}
	case float32:
		if result := numberToProblemType(v); result != nil {
			return *result, nil
		}
	case float64:
		if result := numberToProblemType(v); result != nil {
			return *result, nil
		}
	default:
		return invalidProblemType, fmt.Errorf("invalid type %T", input)
	}
	return invalidProblemType, nil
}

// problemTypesNameMap is a map of enum values to their ProblemType representation
// It is used to convert string representations of enum values into their ProblemType representation.
var problemTypesNameMap = map[string]ProblemType{
	"frontend_ui":    ProblemTypes.PROBLEMTYPEFRONTENDUI,
	"ha_integration": ProblemTypes.PROBLEMTYPEHAINTEGRATION,
	"addon":          ProblemTypes.PROBLEMTYPEADDON,
	"samba":          ProblemTypes.PROBLEMTYPESAMBA,
}

// stringToProblemType converts a string representation of an enum value into its ProblemType representation
// It returns a pointer to the ProblemType representation of the enum value if the string is valid
// Otherwise, it returns nil
func stringToProblemType(s string) *ProblemType {
	if t, ok := problemTypesNameMap[s]; ok {
		return &t
	}
	return nil
}

// numberToProblemType converts a numeric value to a ProblemType
// It returns a pointer to the ProblemType representation of the enum value if the numeric value is valid
// Otherwise, it returns nil
func numberToProblemType[T constraints.Integer | constraints.Float](num T) *ProblemType {
	f := float64(num)
	if math.Floor(f) != f {
		return nil
	}
	i := int(f)
	if i <= 0 || i > len(ProblemTypes.allSlice()) {
		return nil
	}
	result := ProblemTypes.allSlice()[i-1]
	if !result.IsValid() {
		return nil
	}
	return &result
}

// ExhaustiveProblemTypes iterates over all enum values and calls the provided function for each value.
// This function is useful for performing operations on all valid enum values in a loop.
func ExhaustiveProblemTypes(f func(ProblemType)) {
	for _, p := range ProblemTypes.allSlice() {
		f(p)
	}
}

// validProblemTypes is a map of enum values to their validity
var validProblemTypes = map[ProblemType]bool{
	ProblemTypes.PROBLEMTYPEFRONTENDUI:    true,
	ProblemTypes.PROBLEMTYPEHAINTEGRATION: true,
	ProblemTypes.PROBLEMTYPEADDON:         true,
	ProblemTypes.PROBLEMTYPESAMBA:         true,
}

// IsValid checks whether the ProblemTypes value is valid.
// A valid value is one that is defined in the original enum and not marked as invalid.
func (p ProblemType) IsValid() bool {
	return validProblemTypes[p]
}

// MarshalJSON implements the json.Marshaler interface for ProblemType.
// It returns the JSON representation of the enum value as a byte slice.
func (p ProblemType) MarshalJSON() ([]byte, error) {
	return []byte("\"" + p.String() + "\""), nil
}

// UnmarshalJSON implements the json.Unmarshaler interface for ProblemType.
// It parses the JSON representation of the enum value from the byte slice.
// It returns an error if the input is not a valid JSON representation.
func (p *ProblemType) UnmarshalJSON(by []byte) error {
	by = bytes.Trim(bytes.Trim(by, "\""), "\"")
	newp, err := ParseProblemType(by)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for ProblemType.
// It returns the string representation of the enum value as a byte slice
func (p ProblemType) MarshalText() ([]byte, error) {
	return []byte("\"" + p.String() + "\""), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for ProblemType.
// It parses the string representation of the enum value from the byte slice.
// It returns an error if the byte slice does not contain a valid enum value.
func (p *ProblemType) UnmarshalText(by []byte) error {
	newp, err := ParseProblemType(by)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

// Scan implements the database/sql.Scanner interface for ProblemType.
// It parses the string representation of the enum value from the database row.
// It returns an error if the row does not contain a valid enum value.
func (p *ProblemType) Scan(value any) error {
	newp, err := ParseProblemType(value)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

// Value implements the database/sql/driver.Valuer interface for ProblemType.
// It returns the string representation of the enum value.
func (p ProblemType) Value() (driver.Value, error) {
	return p.String(), nil
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for ProblemType.
// It returns the binary representation of the enum value as a byte slice.
func (p ProblemType) MarshalBinary() ([]byte, error) {
	return []byte("\"" + p.String() + "\""), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for ProblemType.
// It parses the binary representation of the enum value from the byte slice.
// It returns an error if the byte slice does not contain a valid enum value.
func (p *ProblemType) UnmarshalBinary(by []byte) error {
	newp, err := ParseProblemType(by)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

// MarshalYAML implements the yaml.Marshaler interface for ProblemType.
// It returns the string representation of the enum value.
func (p ProblemType) MarshalYAML() ([]byte, error) {
	return []byte(p.String()), nil
}

// UnmarshalYAML implements the yaml.Unmarshaler interface for Planet.
// It parses the byte slice representation of the enum value and returns an error
// if the YAML byte slice does not contain a valid enum value.
func (p *ProblemType) UnmarshalYAML(by []byte) error {
	newp, err := ParseProblemType(by)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

// problemtypeNames is a constant string slice containing all enum values cononical absolute names
const problemtypeNames = "frontend_uiha_integrationaddonsamba"

// problemtypeNamesMap is a map of enum values to their canonical absolute
// name positions within the problemtypeNames string slice
var problemtypeNamesMap = map[ProblemType]string{
	ProblemTypes.PROBLEMTYPEFRONTENDUI:    problemtypeNames[0:11],
	ProblemTypes.PROBLEMTYPEHAINTEGRATION: problemtypeNames[11:25],
	ProblemTypes.PROBLEMTYPEADDON:         problemtypeNames[25:30],
	ProblemTypes.PROBLEMTYPESAMBA:         problemtypeNames[30:35],
}

// String implements the Stringer interface.
// It returns the canonical absolute name of the enum value.
func (p ProblemType) String() string {
	if str, ok := problemtypeNamesMap[p]; ok {
		return str
	}
	return fmt.Sprintf("problemtype(%d)", p.problemType)
}

// Compile-time check that all enum values are valid.
// This function is used to ensure that all enum values are defined and valid.
// It is called by the compiler to verify that the enum values are valid.
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the goenums command to generate them again.
	// Does not identify newly added constant values unless order changes
	var x [4]struct{}
	_ = x[problemTypeFrontendUI]
	_ = x[problemTypeHAIntegration-1]
	_ = x[problemTypeAddon-2]
	_ = x[problemTypeSamba-3]
}
