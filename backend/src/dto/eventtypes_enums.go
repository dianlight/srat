// DO NOT EDIT.
// code generated by goenums v0.3.8 at 2025-05-30 15:36:22.
// github.com/zarldev/goenums
//
// using the command:
//
// goenums event_type.go

package dto

import (
	"bytes"
	"database/sql/driver"
	"fmt"
	"iter"
	"strconv"
)

type EventType struct {
	eventType
	Name string
}

type eventtypesContainer struct {
	EVENTHELLO     EventType
	EVENTUPDATE    EventType
	EVENTUPDATING  EventType
	EVENTVOLUMES   EventType
	EVENTHEARTBEAT EventType
	EVENTSHARE     EventType
	EVENTDIRTY     EventType
}

var Eventtypes = eventtypesContainer{
	EVENTHELLO: EventType{
		eventType: eventHello,
		Name:      "\"hello\"",
	},
	EVENTUPDATE: EventType{
		eventType: eventUpdate,
		Name:      "\"update\"",
	},
	EVENTUPDATING: EventType{
		eventType: eventUpdating,
		Name:      "\"updating\"",
	},
	EVENTVOLUMES: EventType{
		eventType: eventVolumes,
		Name:      "\"volumes\"",
	},
	EVENTHEARTBEAT: EventType{
		eventType: eventHeartbeat,
		Name:      "\"heartbeat\"",
	},
	EVENTSHARE: EventType{
		eventType: eventShare,
		Name:      "\"share\"",
	},
	EVENTDIRTY: EventType{
		eventType: eventDirty,
		Name:      "\"dirty\"",
	},
}

// invalidEventType represents an invalid or undefined EventType value.
// It is used as a default return value for failed parsing or conversion operations.
var invalidEventType = EventType{}

// allSlice is an internal method that returns all valid EventType values as a slice.
func (c eventtypesContainer) allSlice() []EventType {
	return []EventType{
		c.EVENTHELLO,
		c.EVENTUPDATE,
		c.EVENTUPDATING,
		c.EVENTVOLUMES,
		c.EVENTHEARTBEAT,
		c.EVENTSHARE,
		c.EVENTDIRTY,
	}
}

// AllSlice returns all valid EventType values as a slice.
func (c eventtypesContainer) AllSlice() []EventType {
	return c.allSlice()
}

// All returns all valid EventType values.
// In Go 1.23+, this can be used with range-over-function iteration:
// ```
//
//	for v := range Eventtypes.All() {
//	    // process each enum value
//	}
//
// ```
func (c eventtypesContainer) All() iter.Seq[EventType] {
	return func(yield func(EventType) bool) {
		for _, v := range c.allSlice() {
			if !yield(v) {
				return
			}
		}
	}
}

// ParseEventType converts various input types to a EventType value.
// It accepts the following types:
// - EventType: returns the value directly
// - string: parses the string representation
// - []byte: converts to string and parses
// - fmt.Stringer: uses the String() result for parsing
// - int/int32/int64: converts the integer to the corresponding enum value
//
// If the input cannot be converted to a valid EventType value, it returns
// the invalidEventType value without an error.
func ParseEventType(a any) (EventType, error) {
	res := invalidEventType
	switch v := a.(type) {
	case EventType:
		return v, nil
	case []byte:
		res = stringToEventType(string(v))
	case string:
		res = stringToEventType(v)
	case fmt.Stringer:
		res = stringToEventType(v.String())
	case int:
		res = intToEventType(v)
	case int64:
		res = intToEventType(int(v))
	case int32:
		res = intToEventType(int(v))
	}
	return res, nil
}

// stringToEventType is an internal function that converts a string to a EventType value.
// It uses a predefined mapping of string representations to enum values.
var (
	eventtypesNameMap = map[string]EventType{
		"eventHello":     Eventtypes.EVENTHELLO,     // primary alias
		"eventUpdate":    Eventtypes.EVENTUPDATE,    // primary alias
		"eventUpdating":  Eventtypes.EVENTUPDATING,  // primary alias
		"eventVolumes":   Eventtypes.EVENTVOLUMES,   // primary alias
		"eventHeartbeat": Eventtypes.EVENTHEARTBEAT, // primary alias
		"eventShare":     Eventtypes.EVENTSHARE,     // primary alias
		"eventDirty":     Eventtypes.EVENTDIRTY,     // primary alias
	}
)

func stringToEventType(s string) EventType {
	if v, ok := eventtypesNameMap[s]; ok {
		return v
	}
	return invalidEventType
}

// intToEventType converts an integer to a EventType value.
// The integer is treated as the ordinal position in the enum sequence.
// The input is adjusted by -7 to account for the enum starting value.
// If the integer doesn't correspond to a valid enum value, invalidEventType is returned.
func intToEventType(i int) EventType {
	i = i - 7
	if i < 0 || i >= len(Eventtypes.allSlice()) {
		return invalidEventType
	}
	return Eventtypes.allSlice()[i]
}

// ExhaustiveEventtypes calls the provided function once for each valid Eventtypes value.
// This is useful for switch statement exhaustiveness checking and for processing all enum values.
// Example usage:
// ```
//
//	ExhaustiveEventtypes(func(x EventType) {
//	    switch x {
//	    case Eventtypes.EventDirty:
//	        // handle EventDirty
//	    }
//	})
//
// ```
func ExhaustiveEventtypes(f func(EventType)) {
	for _, p := range Eventtypes.allSlice() {
		f(p)
	}
}

// validEventtypes is a map of valid EventType values.
var validEventtypes = map[EventType]bool{
	Eventtypes.EVENTHELLO:     true,
	Eventtypes.EVENTUPDATE:    true,
	Eventtypes.EVENTUPDATING:  true,
	Eventtypes.EVENTVOLUMES:   true,
	Eventtypes.EVENTHEARTBEAT: true,
	Eventtypes.EVENTSHARE:     true,
	Eventtypes.EVENTDIRTY:     true,
}

// IsValid checks whether the EventType value is valid.
// A valid value is one that is defined in the original enum and not marked as invalid.
func (p EventType) IsValid() bool {
	return validEventtypes[p]
}

// MarshalJSON implements the json.Marshaler interface for EventType.
// The enum value is encoded as its string representation.
func (p EventType) MarshalJSON() ([]byte, error) {
	return []byte(`"` + p.String() + `"`), nil
}

// UnmarshalJSON implements the json.Unmarshaler interface for EventType.
// It supports unmarshaling from a string representation of the enum.
func (p *EventType) UnmarshalJSON(b []byte) error {
	b = bytes.Trim(bytes.Trim(b, `"`), ` `)
	newp, err := ParseEventType(b)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

// Scan implements the sql.Scanner interface for EventType.
// This allows EventType values to be scanned directly from database queries.
// It supports scanning from strings, []byte, or integers.
func (p *EventType) Scan(value any) error {
	newp, err := ParseEventType(value)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

// Value implements the driver.Valuer interface for EventType.
// This allows EventType values to be saved to databases.
// The value is stored as a string representation of the enum.
func (p EventType) Value() (driver.Value, error) {
	return p.String(), nil
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for EventType.
// It encodes the enum value as a byte slice.
func (p EventType) MarshalBinary() ([]byte, error) {
	return []byte(p.String()), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for EventType.
// It decodes the enum value from a byte slice.
func (p *EventType) UnmarshalBinary(b []byte) error {
	newp, err := ParseEventType(b)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for EventType.
// The enum value is encoded as its string representation.
func (p EventType) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for EventType.
// It supports unmarshaling from a string representation of the enum.
func (p *EventType) UnmarshalText(b []byte) error {
	newp, err := ParseEventType(b)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the goenums command to generate them again.
	// Does not identify newly added constant values unless order changes
	var x [1]struct{}
	_ = x[eventHello-0]
	_ = x[eventUpdate-1]
	_ = x[eventUpdating-2]
	_ = x[eventVolumes-3]
	_ = x[eventHeartbeat-4]
	_ = x[eventShare-5]
	_ = x[eventDirty-6]
}

const eventtypesName = "eventHelloeventUpdateeventUpdatingeventVolumeseventHeartbeateventShareeventDirty"

var eventtypesIdx = [...]uint16{0, 0, 0, 0, 0, 0, 0, 0, 10, 21, 34, 46, 60, 70, 80}

// String returns the string representation of the EventType value.
// For valid values, it returns the name of the constant.
// For invalid values, it returns a string in the format "eventtypes(N)",
// where N is the numeric value.
func (i eventType) String() string {
	if i < 7 || i >= eventType(len(eventtypesIdx)-1) {
		return "eventtypes(" + (strconv.FormatInt(int64(i), 10) + ")")
	}
	return eventtypesName[eventtypesIdx[i]:eventtypesIdx[i+1]]
}
