// Code generated by "enumer -type=MountFlag -json -sql -trimprefix=MF_"; DO NOT EDIT.

package dto

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"strings"
)

const _MountFlagName = "MS_NOUSERMS_RDONLYMS_NOSUIDMS_NODEVMS_NOEXECMS_SYNCHRONOUSMS_REMOUNTMS_MANDLOCKMS_NOATIMEMS_NODIRATIMEMS_BINDMS_RELATIMEMS_LAZYTIME"
const _MountFlagLowerName = "ms_nouserms_rdonlyms_nosuidms_nodevms_noexecms_synchronousms_remountms_mandlockms_noatimems_nodiratimems_bindms_relatimems_lazytime"

var _MountFlagMap = map[MountFlag]string{
	-2147483648: _MountFlagName[0:9],
	1:           _MountFlagName[9:18],
	2:           _MountFlagName[18:27],
	4:           _MountFlagName[27:35],
	8:           _MountFlagName[35:44],
	16:          _MountFlagName[44:58],
	32:          _MountFlagName[58:68],
	64:          _MountFlagName[68:79],
	1024:        _MountFlagName[79:89],
	2048:        _MountFlagName[89:102],
	4096:        _MountFlagName[102:109],
	2097152:     _MountFlagName[109:120],
	33554432:    _MountFlagName[120:131],
}

func (i MountFlag) String() string {
	if str, ok := _MountFlagMap[i]; ok {
		return str
	}
	return fmt.Sprintf("MountFlag(%d)", i)
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _MountFlagNoOp() {
	var x [1]struct{}
	_ = x[MS_NOUSER-(-2147483648)]
	_ = x[MS_RDONLY-(1)]
	_ = x[MS_NOSUID-(2)]
	_ = x[MS_NODEV-(4)]
	_ = x[MS_NOEXEC-(8)]
	_ = x[MS_SYNCHRONOUS-(16)]
	_ = x[MS_REMOUNT-(32)]
	_ = x[MS_MANDLOCK-(64)]
	_ = x[MS_NOATIME-(1024)]
	_ = x[MS_NODIRATIME-(2048)]
	_ = x[MS_BIND-(4096)]
	_ = x[MS_RELATIME-(2097152)]
	_ = x[MS_LAZYTIME-(33554432)]
}

var _MountFlagValues = []MountFlag{MS_NOUSER, MS_RDONLY, MS_NOSUID, MS_NODEV, MS_NOEXEC, MS_SYNCHRONOUS, MS_REMOUNT, MS_MANDLOCK, MS_NOATIME, MS_NODIRATIME, MS_BIND, MS_RELATIME, MS_LAZYTIME}

var _MountFlagNameToValueMap = map[string]MountFlag{
	_MountFlagName[0:9]:          MS_NOUSER,
	_MountFlagLowerName[0:9]:     MS_NOUSER,
	_MountFlagName[9:18]:         MS_RDONLY,
	_MountFlagLowerName[9:18]:    MS_RDONLY,
	_MountFlagName[18:27]:        MS_NOSUID,
	_MountFlagLowerName[18:27]:   MS_NOSUID,
	_MountFlagName[27:35]:        MS_NODEV,
	_MountFlagLowerName[27:35]:   MS_NODEV,
	_MountFlagName[35:44]:        MS_NOEXEC,
	_MountFlagLowerName[35:44]:   MS_NOEXEC,
	_MountFlagName[44:58]:        MS_SYNCHRONOUS,
	_MountFlagLowerName[44:58]:   MS_SYNCHRONOUS,
	_MountFlagName[58:68]:        MS_REMOUNT,
	_MountFlagLowerName[58:68]:   MS_REMOUNT,
	_MountFlagName[68:79]:        MS_MANDLOCK,
	_MountFlagLowerName[68:79]:   MS_MANDLOCK,
	_MountFlagName[79:89]:        MS_NOATIME,
	_MountFlagLowerName[79:89]:   MS_NOATIME,
	_MountFlagName[89:102]:       MS_NODIRATIME,
	_MountFlagLowerName[89:102]:  MS_NODIRATIME,
	_MountFlagName[102:109]:      MS_BIND,
	_MountFlagLowerName[102:109]: MS_BIND,
	_MountFlagName[109:120]:      MS_RELATIME,
	_MountFlagLowerName[109:120]: MS_RELATIME,
	_MountFlagName[120:131]:      MS_LAZYTIME,
	_MountFlagLowerName[120:131]: MS_LAZYTIME,
}

var _MountFlagNames = []string{
	_MountFlagName[0:9],
	_MountFlagName[9:18],
	_MountFlagName[18:27],
	_MountFlagName[27:35],
	_MountFlagName[35:44],
	_MountFlagName[44:58],
	_MountFlagName[58:68],
	_MountFlagName[68:79],
	_MountFlagName[79:89],
	_MountFlagName[89:102],
	_MountFlagName[102:109],
	_MountFlagName[109:120],
	_MountFlagName[120:131],
}

// MountFlagString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func MountFlagString(s string) (MountFlag, error) {
	if val, ok := _MountFlagNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _MountFlagNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to MountFlag values", s)
}

// MountFlagValues returns all values of the enum
func MountFlagValues() []MountFlag {
	return _MountFlagValues
}

// MountFlagStrings returns a slice of all String values of the enum
func MountFlagStrings() []string {
	strs := make([]string, len(_MountFlagNames))
	copy(strs, _MountFlagNames)
	return strs
}

// IsAMountFlag returns "true" if the value is listed in the enum definition. "false" otherwise
func (i MountFlag) IsAMountFlag() bool {
	_, ok := _MountFlagMap[i]
	return ok
}

// MarshalJSON implements the json.Marshaler interface for MountFlag
func (i MountFlag) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for MountFlag
func (i *MountFlag) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("MountFlag should be a string, got %s", data)
	}

	var err error
	*i, err = MountFlagString(s)
	return err
}

func (i MountFlag) Value() (driver.Value, error) {
	return i.String(), nil
}

func (i *MountFlag) Scan(value interface{}) error {
	if value == nil {
		return nil
	}

	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of MountFlag: %[1]T(%[1]v)", value)
	}

	val, err := MountFlagString(str)
	if err != nil {
		return err
	}

	*i = val
	return nil
}
