// Code generated by github.com/jmattheis/goverter, DO NOT EDIT.
//go:build !goverter

package converter

import (
	config "github.com/dianlight/srat/config"
	dto "github.com/dianlight/srat/dto"
	xhashes "github.com/shomali11/util/xhashes"
	osutil "github.com/snapcore/snapd/osutil"
)

type ConfigToDtoConverterImpl struct{}

func (c *ConfigToDtoConverterImpl) ConfigToSettings(source config.Config, target *dto.Settings) error {
	target.Hostname = source.Hostname
	target.Workgroup = source.Workgroup
	if source.Mountoptions != nil {
		target.Mountoptions = make([]string, len(source.Mountoptions))
		for i := 0; i < len(source.Mountoptions); i++ {
			target.Mountoptions[i] = source.Mountoptions[i]
		}
	}
	if source.AllowHost != nil {
		target.AllowHost = make([]string, len(source.AllowHost))
		for j := 0; j < len(source.AllowHost); j++ {
			target.AllowHost[j] = source.AllowHost[j]
		}
	}
	target.CompatibilityMode = source.CompatibilityMode
	if source.Interfaces != nil {
		target.Interfaces = make([]string, len(source.Interfaces))
		for k := 0; k < len(source.Interfaces); k++ {
			target.Interfaces[k] = source.Interfaces[k]
		}
	}
	target.BindAllInterfaces = source.BindAllInterfaces
	target.LogLevel = source.LogLevel
	target.MultiChannel = source.MultiChannel
	dtoUpdateChannel, err := dto.ParseUpdateChannel(source.UpdateChannel)
	if err != nil {
		return err
	}
	target.UpdateChannel = dtoUpdateChannel
	dtoTelemetryMode, err := dto.ParseTelemetryMode(source.TelemetryMode)
	if err != nil {
		return err
	}
	target.TelemetryMode = dtoTelemetryMode
	return nil
}
func (c *ConfigToDtoConverterImpl) ConfigToUser(source config.Config, target *dto.User) error {
	if source.Username != "" {
		target.Username = source.Username
	}
	if source.Password != "" {
		target.Password = source.Password
	}
	return nil
}
func (c *ConfigToDtoConverterImpl) OtherUserToUser(source config.User, target *dto.User) error {
	if source.Username != "" {
		target.Username = source.Username
	}
	if source.Password != "" {
		target.Password = source.Password
	}
	return nil
}
func (c *ConfigToDtoConverterImpl) ShareToMountPointData(source config.Share, target *dto.MountPointData) error {
	if source.Path != "" {
		target.Path = source.Path
	}
	if source.Path != "" {
		target.PathHash = xhashes.SHA1(source.Path)
	}
	if source.Path != "" {
		target.Type = pathToType(source.Path)
	}
	if source.FS != "" {
		pString := source.FS
		target.FSType = &pString
	}
	if source.Path != "" {
		target.Device = PathToSource(source.Path)
	}
	if source.Path != "" {
		xbool, err := osutil.IsMounted(source.Path)
		if err != nil {
			return err
		}
		target.IsMounted = xbool
	}
	return nil
}
func (c *ConfigToDtoConverterImpl) ShareToSharedResourceNoMountPointData(source config.Share, target *dto.SharedResource, context []dto.User) error {
	if source.Name != "" {
		target.Name = source.Name
	}
	if source.Disabled != false {
		pBool := source.Disabled
		target.Disabled = &pBool
	}
	if source.Users != nil {
		target.Users = make([]dto.User, len(source.Users))
		for i := 0; i < len(source.Users); i++ {
			dtoUser, err := StringToDtoUser(source.Users[i], context)
			if err != nil {
				return err
			}
			target.Users[i] = dtoUser
		}
	}
	if source.RoUsers != nil {
		target.RoUsers = make([]dto.User, len(source.RoUsers))
		for j := 0; j < len(source.RoUsers); j++ {
			dtoUser2, err := StringToDtoUser(source.RoUsers[j], context)
			if err != nil {
				return err
			}
			target.RoUsers[j] = dtoUser2
		}
	}
	if source.TimeMachine != false {
		pBool2 := source.TimeMachine
		target.TimeMachine = &pBool2
	}
	if source.RecycleBin != false {
		pBool3 := source.RecycleBin
		target.RecycleBin = &pBool3
	}
	if source.Usage != "" {
		target.Usage = dto.HAMountUsage(source.Usage)
	}
	if source.VetoFiles != nil {
		target.VetoFiles = make([]string, len(source.VetoFiles))
		for k := 0; k < len(source.VetoFiles); k++ {
			target.VetoFiles[k] = source.VetoFiles[k]
		}
	}
	return nil
}
func (c *ConfigToDtoConverterImpl) SharedResourceToShare(source dto.SharedResource, target *config.Share) error {
	if source.Name != "" {
		target.Name = source.Name
	}
	var pString *string
	if source.MountPointData != nil {
		pString = &source.MountPointData.Path
	}
	if pString != nil {
		target.Path = *pString
	}
	var pString2 *string
	if source.MountPointData != nil {
		pString2 = source.MountPointData.FSType
	}
	if pString2 != nil {
		target.FS = *pString2
	}
	if source.Disabled != nil {
		target.Disabled = *source.Disabled
	}
	if source.Users != nil {
		target.Users = make([]string, len(source.Users))
		for i := 0; i < len(source.Users); i++ {
			target.Users[i] = DtoUserToString(source.Users[i])
		}
	}
	if source.RoUsers != nil {
		target.RoUsers = make([]string, len(source.RoUsers))
		for j := 0; j < len(source.RoUsers); j++ {
			target.RoUsers[j] = DtoUserToString(source.RoUsers[j])
		}
	}
	if source.TimeMachine != nil {
		target.TimeMachine = *source.TimeMachine
	}
	if source.RecycleBin != nil {
		target.RecycleBin = *source.RecycleBin
	}
	if source.Usage != "" {
		target.Usage = string(source.Usage)
	}
	if source.VetoFiles != nil {
		target.VetoFiles = make([]string, len(source.VetoFiles))
		for k := 0; k < len(source.VetoFiles); k++ {
			target.VetoFiles[k] = source.VetoFiles[k]
		}
	}
	return nil
}
func (c *ConfigToDtoConverterImpl) UserToOtherUser(source dto.User, target *config.User) error {
	if source.Username != "" {
		target.Username = source.Username
	}
	if source.Password != "" {
		target.Password = source.Password
	}
	return nil
}
