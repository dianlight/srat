// Code generated by github.com/jmattheis/goverter, DO NOT EDIT.
//go:build !goverter

package converter

import (
	config "github.com/dianlight/srat/config"
	dbom "github.com/dianlight/srat/dbom"
	dto "github.com/dianlight/srat/dto"
	datatypes "gorm.io/datatypes"
)

type ConfigToDbomConverterImpl struct{}

func (c *ConfigToDbomConverterImpl) ConfigToSambaUser(source config.Config, target *dbom.SambaUser) error {
	if source.Username != "" {
		target.Username = source.Username
	}
	if source.Password != "" {
		target.Password = source.Password
	}
	return nil
}
func (c *ConfigToDbomConverterImpl) ExportedShareToShare(source dbom.ExportedShare, target *config.Share) error {
	if source.Name != "" {
		target.Name = source.Name
	}
	if source.MountPointData.Path != "" {
		target.Path = source.MountPointData.Path
	}
	if source.MountPointData.FSType != "" {
		target.FS = source.MountPointData.FSType
	}
	if source.Disabled != nil {
		target.Disabled = *source.Disabled
	}
	if source.Users != nil {
		target.Users = make([]string, len(source.Users))
		for i := 0; i < len(source.Users); i++ {
			target.Users[i] = SambaUserToString(source.Users[i])
		}
	}
	if source.RoUsers != nil {
		target.RoUsers = make([]string, len(source.RoUsers))
		for j := 0; j < len(source.RoUsers); j++ {
			target.RoUsers[j] = SambaUserToString(source.RoUsers[j])
		}
	}
	if source.TimeMachine != false {
		target.TimeMachine = source.TimeMachine
	}
	if source.RecycleBin != false {
		pBool := source.RecycleBin
		target.RecycleBin = &pBool
	}
	if source.GuestOk != false {
		pBool2 := source.GuestOk
		target.GuestOk = &pBool2
	}
	if source.TimeMachineMaxSize != "" {
		pString := source.TimeMachineMaxSize
		target.TimeMachineMaxSize = &pString
	}
	if source.Usage != "" {
		target.Usage = string(source.Usage)
	}
	target.VetoFiles = c.datatypesJSONSliceToStringList(source.VetoFiles)
	return nil
}
func (c *ConfigToDbomConverterImpl) SambaUserToUser(source dbom.SambaUser, target *config.User) error {
	if source.Username != "" {
		target.Username = source.Username
	}
	if source.Password != "" {
		target.Password = source.Password
	}
	return nil
}
func (c *ConfigToDbomConverterImpl) ShareToExportedShareNoMountPointPath(source config.Share, target *dbom.ExportedShare, context *dbom.SambaUsers) error {
	if source.Name != "" {
		target.Name = source.Name
	}
	if source.Disabled != false {
		pBool := source.Disabled
		target.Disabled = &pBool
	}
	if source.Users != nil {
		target.Users = make([]dbom.SambaUser, len(source.Users))
		for i := 0; i < len(source.Users); i++ {
			dbomSambaUser, err := StringToSambaUser(source.Users[i], context)
			if err != nil {
				return err
			}
			target.Users[i] = dbomSambaUser
		}
	}
	if source.RoUsers != nil {
		target.RoUsers = make([]dbom.SambaUser, len(source.RoUsers))
		for j := 0; j < len(source.RoUsers); j++ {
			dbomSambaUser2, err := StringToSambaUser(source.RoUsers[j], context)
			if err != nil {
				return err
			}
			target.RoUsers[j] = dbomSambaUser2
		}
	}
	target.VetoFiles = c.stringListToDatatypesJSONSlice(source.VetoFiles)
	if source.TimeMachine != false {
		target.TimeMachine = source.TimeMachine
	}
	if source.RecycleBin != nil {
		target.RecycleBin = *source.RecycleBin
	}
	if source.GuestOk != nil {
		target.GuestOk = *source.GuestOk
	}
	if source.TimeMachineMaxSize != nil {
		target.TimeMachineMaxSize = *source.TimeMachineMaxSize
	}
	if source.Usage != "" {
		target.Usage = dto.HAMountUsage(source.Usage)
	}
	if source.Path != "" {
		target.MountPointDataPath = source.Path
	}
	return nil
}
func (c *ConfigToDbomConverterImpl) ShareToMountPointPath(source config.Share, target *dbom.MountPointPath) error {
	if source.Path != "" {
		target.Path = source.Path
	}
	if source.Path != "" {
		target.Type = pathToType(source.Path)
	}
	if source.Path != "" {
		target.Device = PathToSource(source.Path)
	}
	if source.FS != "" {
		target.FSType = source.FS
	}
	return nil
}
func (c *ConfigToDbomConverterImpl) UserToUSambaUser(source config.User, target *dbom.SambaUser) error {
	if source.Username != "" {
		target.Username = source.Username
	}
	if source.Password != "" {
		target.Password = source.Password
	}
	return nil
}
func (c *ConfigToDbomConverterImpl) datatypesJSONSliceToStringList(source datatypes.JSONSlice[string]) []string {
	var stringList []string
	if source != nil {
		stringList = make([]string, len(source))
		for i := 0; i < len(source); i++ {
			stringList[i] = source[i]
		}
	}
	return stringList
}
func (c *ConfigToDbomConverterImpl) stringListToDatatypesJSONSlice(source []string) datatypes.JSONSlice[string] {
	var datatypesJSONSlice datatypes.JSONSlice[string]
	if source != nil {
		datatypesJSONSlice = make(datatypes.JSONSlice[string], len(source))
		for i := 0; i < len(source); i++ {
			datatypesJSONSlice[i] = source[i]
		}
	}
	return datatypesJSONSlice
}
