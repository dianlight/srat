// Code generated by github.com/jmattheis/goverter, DO NOT EDIT.
//go:build !goverter

package converter

import (
	dbom "github.com/dianlight/srat/dbom"
	dto "github.com/dianlight/srat/dto"
	osutil "github.com/dianlight/srat/internal/osutil"
	xhashes "github.com/shomali11/util/xhashes"
	datatypes "gorm.io/datatypes"
)

type DtoToDbomConverterImpl struct{}

func (c *DtoToDbomConverterImpl) ExportedShareToSharedResource(source dbom.ExportedShare) (dto.SharedResource, error) {
	var dtoSharedResource dto.SharedResource
	dtoSharedResource.Name = source.Name
	dtoSharedResource.Disabled = source.Disabled
	dtoUserList, err := c.SambaUsersToUsers(source.Users)
	if err != nil {
		return dtoSharedResource, err
	}
	dtoSharedResource.Users = dtoUserList
	dtoUserList2, err := c.SambaUsersToUsers(source.RoUsers)
	if err != nil {
		return dtoSharedResource, err
	}
	dtoSharedResource.RoUsers = dtoUserList2
	pBool := source.TimeMachine
	dtoSharedResource.TimeMachine = &pBool
	pBool2 := source.RecycleBin
	dtoSharedResource.RecycleBin = &pBool2
	pBool3 := source.GuestOk
	dtoSharedResource.GuestOk = &pBool3
	pString := source.TimeMachineMaxSize
	dtoSharedResource.TimeMachineMaxSize = &pString
	dtoSharedResource.Usage = source.Usage
	dtoSharedResource.VetoFiles = c.datatypesJSONSliceToStringList(source.VetoFiles)
	pDtoMountPointData, err := c.dbomMountPointPathToPDtoMountPointData(source.MountPointData)
	if err != nil {
		return dtoSharedResource, err
	}
	dtoSharedResource.MountPointData = pDtoMountPointData
	return dtoSharedResource, nil
}
func (c *DtoToDbomConverterImpl) ExportedSharesToSharedResources(source *[]dbom.ExportedShare) (*[]dto.SharedResource, error) {
	var pDtoSharedResourceList *[]dto.SharedResource
	if source != nil {
		var dtoSharedResourceList []dto.SharedResource
		if (*source) != nil {
			dtoSharedResourceList = make([]dto.SharedResource, len((*source)))
			for i := 0; i < len((*source)); i++ {
				dtoSharedResource, err := c.ExportedShareToSharedResource((*source)[i])
				if err != nil {
					return nil, err
				}
				dtoSharedResourceList[i] = dtoSharedResource
			}
		}
		pDtoSharedResourceList = &dtoSharedResourceList
	}
	return pDtoSharedResourceList, nil
}
func (c *DtoToDbomConverterImpl) HDIdleDeviceDTOToHDIdleDevice(source dto.HDIdleDeviceDTO) (dbom.HDIdleDevice, error) {
	var dbomHDIdleDevice dbom.HDIdleDevice
	dbomHDIdleDevice.DevicePath = source.DevicePath
	dbomHDIdleDevice.IdleTime = source.IdleTime
	dbomHDIdleDevice.CommandType = c.dtoHdidleCommandToPDtoHdidleCommand(source.CommandType)
	dbomHDIdleDevice.PowerCondition = source.PowerCondition
	dbomHDIdleDevice.Enabled = source.Enabled
	return dbomHDIdleDevice, nil
}
func (c *DtoToDbomConverterImpl) HDIdleDeviceToHDIdleDeviceDTO(source dbom.HDIdleDevice) (dto.HDIdleDeviceDTO, error) {
	var dtoHDIdleDeviceDTO dto.HDIdleDeviceDTO
	dtoHDIdleDeviceDTO.DevicePath = source.DevicePath
	dtoHDIdleDeviceDTO.IdleTime = source.IdleTime
	dtoHDIdleDeviceDTO.CommandType = c.pDtoHdidleCommandToDtoHdidleCommand(source.CommandType)
	dtoHDIdleDeviceDTO.PowerCondition = source.PowerCondition
	dtoHDIdleDeviceDTO.Enabled = source.Enabled
	return dtoHDIdleDeviceDTO, nil
}
func (c *DtoToDbomConverterImpl) MountFlagsToMountDataFlags(source []dto.MountFlag) dbom.MounDataFlags {
	var dbomMounDataFlags dbom.MounDataFlags
	if source != nil {
		dbomMounDataFlags = make(dbom.MounDataFlags, len(source))
		for i := 0; i < len(source); i++ {
			dbomMounDataFlags[i] = c.dtoMountFlagToDbomMounDataFlag(source[i])
		}
	}
	return dbomMounDataFlags
}
func (c *DtoToDbomConverterImpl) MountPointDataToMountPointPath(source dto.MountPointData, target *dbom.MountPointPath) error {
	if source.Path != "" {
		target.Path = source.Path
	}
	if source.Type != "" {
		target.Type = source.Type
	}
	if source.DeviceId != "" {
		target.DeviceId = source.DeviceId
	}
	if source.FSType != nil {
		target.FSType = *source.FSType
	}
	target.Flags = c.pDtoMountFlagsToPDbomMounDataFlags(source.Flags)
	target.Data = c.pDtoMountFlagsToPDbomMounDataFlags(source.CustomFlags)
	if source.IsToMountAtStartup != nil {
		target.IsToMountAtStartup = source.IsToMountAtStartup
	}
	if source.Shares != nil {
		target.Shares = make([]dbom.ExportedShare, len(source.Shares))
		for i := 0; i < len(source.Shares); i++ {
			dbomExportedShare, err := c.sharedResourceToExportedShare(source.Shares[i])
			if err != nil {
				return err
			}
			target.Shares[i] = dbomExportedShare
		}
	}
	return nil
}
func (c *DtoToDbomConverterImpl) MountPointPathToMountPointData(source dbom.MountPointPath, target *dto.MountPointData, context []dto.Disk) error {
	if source.Path != "" {
		target.DiskLabel = DiskLabelFromPath(source.Path)
	}
	if source.Path != "" {
		target.DiskSerial = DiskSerialFromPath(source.Path)
	}
	if source.Path != "" {
		target.DiskSize = DiskSizeFromPath(source.Path)
	}
	if source.Path != "" {
		target.Path = source.Path
	}
	if source.Path != "" {
		target.PathHash = xhashes.SHA1(source.Path)
	}
	if source.Type != "" {
		target.Type = source.Type
	}
	if source.FSType != "" {
		pString := source.FSType
		target.FSType = &pString
	}
	pDtoMountFlags, err := c.pDbomMounDataFlagsToPDtoMountFlags(source.Flags)
	if err != nil {
		return err
	}
	target.Flags = pDtoMountFlags
	pDtoMountFlags2, err := c.pDbomMounDataFlagsToPDtoMountFlags(source.Data)
	if err != nil {
		return err
	}
	target.CustomFlags = pDtoMountFlags2
	if source.DeviceId != "" {
		target.DeviceId = source.DeviceId
	}
	if source.DeviceId != "" {
		target.Partition = partitionFromDeviceId(source.DeviceId, context)
	}
	if source.Path != "" {
		xbool, err := osutil.IsMounted(source.Path)
		if err != nil {
			return err
		}
		target.IsMounted = xbool
	}
	if source.Path != "" {
		xbool2, err := isPathDirNotExists(source.Path)
		if err != nil {
			return err
		}
		target.IsInvalid = xbool2
	}
	if source.IsToMountAtStartup != nil {
		target.IsToMountAtStartup = source.IsToMountAtStartup
	}
	if source.Path != "" {
		target.IsWriteSupported = isWriteSupported(source.Path)
	}
	if source.FSType != "" {
		target.TimeMachineSupport = TimeMachineSupportFromFS(source.FSType)
	}
	if source.Shares != nil {
		target.Shares = make([]dto.SharedResource, len(source.Shares))
		for i := 0; i < len(source.Shares); i++ {
			dtoSharedResource, err := c.ExportedShareToSharedResource(source.Shares[i])
			if err != nil {
				return err
			}
			target.Shares[i] = dtoSharedResource
		}
	}
	return nil
}
func (c *DtoToDbomConverterImpl) MountPointPathsToMountPointDatas(source []dbom.MountPointPath) ([]*dto.MountPointData, error) {
	var pDtoMountPointDataList []*dto.MountPointData
	if source != nil {
		pDtoMountPointDataList = make([]*dto.MountPointData, len(source))
		for i := 0; i < len(source); i++ {
			pDtoMountPointData, err := c.dbomMountPointPathToPDtoMountPointData(source[i])
			if err != nil {
				return nil, err
			}
			pDtoMountPointDataList[i] = pDtoMountPointData
		}
	}
	return pDtoMountPointDataList, nil
}
func (c *DtoToDbomConverterImpl) SambaUserToUser(source dbom.SambaUser, target *dto.User) error {
	target.Username = source.Username
	target.Password = source.Password
	target.IsAdmin = source.IsAdmin
	if source.RwShares != nil {
		target.RwShares = make([]string, len(source.RwShares))
		for i := 0; i < len(source.RwShares); i++ {
			target.RwShares[i] = exportedShareToString(source.RwShares[i])
		}
	}
	if source.RoShares != nil {
		target.RoShares = make([]string, len(source.RoShares))
		for j := 0; j < len(source.RoShares); j++ {
			target.RoShares[j] = exportedShareToString(source.RoShares[j])
		}
	}
	return nil
}
func (c *DtoToDbomConverterImpl) SambaUsersToUsers(source []dbom.SambaUser) ([]dto.User, error) {
	var dtoUserList []dto.User
	if source != nil {
		dtoUserList = make([]dto.User, len(source))
		for i := 0; i < len(source); i++ {
			dtoUserList[i] = c.dbomSambaUserToDtoUser(source[i])
		}
	}
	return dtoUserList, nil
}
func (c *DtoToDbomConverterImpl) SharedResourceToExportedShareNoUsersNoMountPointPath(source dto.SharedResource, target *dbom.ExportedShare) error {
	if source.Name != "" {
		target.Name = source.Name
	}
	if source.Disabled != nil {
		target.Disabled = source.Disabled
	}
	target.VetoFiles = c.stringListToDatatypesJSONSlice(source.VetoFiles)
	if source.TimeMachine != nil {
		target.TimeMachine = *source.TimeMachine
	}
	if source.RecycleBin != nil {
		target.RecycleBin = *source.RecycleBin
	}
	if source.GuestOk != nil {
		target.GuestOk = *source.GuestOk
	}
	if source.TimeMachineMaxSize != nil {
		target.TimeMachineMaxSize = *source.TimeMachineMaxSize
	}
	if source.Usage != "" {
		target.Usage = source.Usage
	}
	var pString *string
	if source.MountPointData != nil {
		pString = &source.MountPointData.Path
	}
	if pString != nil {
		target.MountPointDataPath = *pString
	}
	return nil
}
func (c *DtoToDbomConverterImpl) SharedResourcesToExportedShares(source *[]dto.SharedResource) (*[]dbom.ExportedShare, error) {
	var pDbomExportedShareList *[]dbom.ExportedShare
	if source != nil {
		var dbomExportedShareList []dbom.ExportedShare
		if (*source) != nil {
			dbomExportedShareList = make([]dbom.ExportedShare, len((*source)))
			for i := 0; i < len((*source)); i++ {
				dbomExportedShare, err := c.sharedResourceToExportedShare((*source)[i])
				if err != nil {
					return nil, err
				}
				dbomExportedShareList[i] = dbomExportedShare
			}
		}
		pDbomExportedShareList = &dbomExportedShareList
	}
	return pDbomExportedShareList, nil
}
func (c *DtoToDbomConverterImpl) UserToSambaUser(source dto.User, target *dbom.SambaUser) error {
	if source.Username != "" {
		target.Username = source.Username
	}
	if source.Password != "" {
		target.Password = source.Password
	}
	if source.IsAdmin != false {
		target.IsAdmin = source.IsAdmin
	}
	if source.RwShares != nil {
		target.RwShares = make([]dbom.ExportedShare, len(source.RwShares))
		for i := 0; i < len(source.RwShares); i++ {
			target.RwShares[i] = stringToExportedShare(source.RwShares[i])
		}
	}
	if source.RoShares != nil {
		target.RoShares = make([]dbom.ExportedShare, len(source.RoShares))
		for j := 0; j < len(source.RoShares); j++ {
			target.RoShares[j] = stringToExportedShare(source.RoShares[j])
		}
	}
	return nil
}
func (c *DtoToDbomConverterImpl) datatypesJSONSliceToStringList(source datatypes.JSONSlice[string]) []string {
	var stringList []string
	if source != nil {
		stringList = make([]string, len(source))
		for i := 0; i < len(source); i++ {
			stringList[i] = source[i]
		}
	}
	return stringList
}
func (c *DtoToDbomConverterImpl) dbomMounDataFlagsToDtoMountFlags(source dbom.MounDataFlags) (dto.MountFlags, error) {
	var dtoMountFlags dto.MountFlags
	if source != nil {
		dtoMountFlags = make(dto.MountFlags, len(source))
		for i := 0; i < len(source); i++ {
			dtoMountFlag, err := c.mountDataFlagToMountFlag(source[i])
			if err != nil {
				return nil, err
			}
			dtoMountFlags[i] = dtoMountFlag
		}
	}
	return dtoMountFlags, nil
}
func (c *DtoToDbomConverterImpl) dbomMountPointPathToPDtoMountPointData(source dbom.MountPointPath) (*dto.MountPointData, error) {
	dtoMountPointData, err := c.mountPointPathToMountPointData(source)
	if err != nil {
		return nil, err
	}
	return &dtoMountPointData, nil
}
func (c *DtoToDbomConverterImpl) dbomSambaUserToDtoUser(source dbom.SambaUser) dto.User {
	var dtoUser dto.User
	dtoUser.Username = source.Username
	dtoUser.Password = source.Password
	dtoUser.IsAdmin = source.IsAdmin
	if source.RwShares != nil {
		dtoUser.RwShares = make([]string, len(source.RwShares))
		for i := 0; i < len(source.RwShares); i++ {
			dtoUser.RwShares[i] = exportedShareToString(source.RwShares[i])
		}
	}
	if source.RoShares != nil {
		dtoUser.RoShares = make([]string, len(source.RoShares))
		for j := 0; j < len(source.RoShares); j++ {
			dtoUser.RoShares[j] = exportedShareToString(source.RoShares[j])
		}
	}
	return dtoUser
}
func (c *DtoToDbomConverterImpl) dtoHdidleCommandToPDtoHdidleCommand(source dto.HdidleCommand) *dto.HdidleCommand {
	return &source
}
func (c *DtoToDbomConverterImpl) dtoMountFlagToDbomMounDataFlag(source dto.MountFlag) dbom.MounDataFlag {
	var dbomMounDataFlag dbom.MounDataFlag
	dbomMounDataFlag.Name = source.Name
	dbomMounDataFlag.NeedsValue = source.NeedsValue
	dbomMounDataFlag.FlagValue = source.FlagValue
	return dbomMounDataFlag
}
func (c *DtoToDbomConverterImpl) dtoMountFlagsToDbomMounDataFlags(source dto.MountFlags) dbom.MounDataFlags {
	var dbomMounDataFlags dbom.MounDataFlags
	if source != nil {
		dbomMounDataFlags = make(dbom.MounDataFlags, len(source))
		for i := 0; i < len(source); i++ {
			dbomMounDataFlags[i] = c.dtoMountFlagToDbomMounDataFlag(source[i])
		}
	}
	return dbomMounDataFlags
}
func (c *DtoToDbomConverterImpl) mountDataFlagToMountFlag(source dbom.MounDataFlag) (dto.MountFlag, error) {
	var dtoMountFlag dto.MountFlag
	dtoMountFlag.Name = source.Name
	dtoMountFlag.NeedsValue = source.NeedsValue
	dtoMountFlag.FlagValue = source.FlagValue
	return dtoMountFlag, nil
}
func (c *DtoToDbomConverterImpl) mountPointDataToMountPointPath(source dto.MountPointData) (dbom.MountPointPath, error) {
	var dbomMountPointPath dbom.MountPointPath
	dbomMountPointPath.Path = source.Path
	dbomMountPointPath.Type = source.Type
	xstring, err := mountPathToDeviceId(source.Path)
	if err != nil {
		return dbomMountPointPath, err
	}
	dbomMountPointPath.DeviceId = xstring
	if source.FSType != nil {
		dbomMountPointPath.FSType = *source.FSType
	}
	dbomMountPointPath.Flags = c.pDtoMountFlagsToPDbomMounDataFlags(source.Flags)
	dbomMountPointPath.Data = c.pDtoMountFlagsToPDbomMounDataFlags(source.CustomFlags)
	dbomMountPointPath.IsToMountAtStartup = source.IsToMountAtStartup
	if source.Shares != nil {
		dbomMountPointPath.Shares = make([]dbom.ExportedShare, len(source.Shares))
		for i := 0; i < len(source.Shares); i++ {
			dbomExportedShare, err := c.sharedResourceToExportedShare(source.Shares[i])
			if err != nil {
				return dbomMountPointPath, err
			}
			dbomMountPointPath.Shares[i] = dbomExportedShare
		}
	}
	return dbomMountPointPath, nil
}
func (c *DtoToDbomConverterImpl) mountPointPathToMountPointData(source dbom.MountPointPath) (dto.MountPointData, error) {
	var dtoMountPointData dto.MountPointData
	dtoMountPointData.DiskLabel = DiskLabelFromPath(source.Path)
	dtoMountPointData.DiskSerial = DiskSerialFromPath(source.Path)
	dtoMountPointData.DiskSize = DiskSizeFromPath(source.Path)
	dtoMountPointData.Path = source.Path
	dtoMountPointData.PathHash = xhashes.SHA1(source.Path)
	dtoMountPointData.Type = source.Type
	pString := source.FSType
	dtoMountPointData.FSType = &pString
	pDtoMountFlags, err := c.pDbomMounDataFlagsToPDtoMountFlags(source.Flags)
	if err != nil {
		return dtoMountPointData, err
	}
	dtoMountPointData.Flags = pDtoMountFlags
	pDtoMountFlags2, err := c.pDbomMounDataFlagsToPDtoMountFlags(source.Data)
	if err != nil {
		return dtoMountPointData, err
	}
	dtoMountPointData.CustomFlags = pDtoMountFlags2
	dtoMountPointData.DeviceId = source.DeviceId
	xbool, err := osutil.IsMounted(source.Path)
	if err != nil {
		return dtoMountPointData, err
	}
	dtoMountPointData.IsMounted = xbool
	xbool2, err := isPathDirNotExists(source.Path)
	if err != nil {
		return dtoMountPointData, err
	}
	dtoMountPointData.IsInvalid = xbool2
	dtoMountPointData.IsToMountAtStartup = source.IsToMountAtStartup
	dtoMountPointData.IsWriteSupported = isWriteSupported(source.Path)
	dtoMountPointData.TimeMachineSupport = TimeMachineSupportFromFS(source.FSType)
	if source.Shares != nil {
		dtoMountPointData.Shares = make([]dto.SharedResource, len(source.Shares))
		for i := 0; i < len(source.Shares); i++ {
			dtoSharedResource, err := c.ExportedShareToSharedResource(source.Shares[i])
			if err != nil {
				return dtoMountPointData, err
			}
			dtoMountPointData.Shares[i] = dtoSharedResource
		}
	}
	return dtoMountPointData, nil
}
func (c *DtoToDbomConverterImpl) pDbomMounDataFlagsToPDtoMountFlags(source *dbom.MounDataFlags) (*dto.MountFlags, error) {
	var pDtoMountFlags *dto.MountFlags
	if source != nil {
		dtoMountFlags, err := c.dbomMounDataFlagsToDtoMountFlags((*source))
		if err != nil {
			return nil, err
		}
		pDtoMountFlags = &dtoMountFlags
	}
	return pDtoMountFlags, nil
}
func (c *DtoToDbomConverterImpl) pDtoHdidleCommandToDtoHdidleCommand(source *dto.HdidleCommand) dto.HdidleCommand {
	var dtoHdidleCommand dto.HdidleCommand
	if source != nil {
		dtoHdidleCommand = (*source)
	}
	return dtoHdidleCommand
}
func (c *DtoToDbomConverterImpl) pDtoMountFlagsToPDbomMounDataFlags(source *dto.MountFlags) *dbom.MounDataFlags {
	var pDbomMounDataFlags *dbom.MounDataFlags
	if source != nil {
		dbomMounDataFlags := c.dtoMountFlagsToDbomMounDataFlags((*source))
		pDbomMounDataFlags = &dbomMounDataFlags
	}
	return pDbomMounDataFlags
}
func (c *DtoToDbomConverterImpl) pDtoMountPointDataToDbomMountPointPath(source *dto.MountPointData) (dbom.MountPointPath, error) {
	var dbomMountPointPath dbom.MountPointPath
	if source != nil {
		dbomMountPointPath2, err := c.mountPointDataToMountPointPath((*source))
		if err != nil {
			return dbomMountPointPath, err
		}
		dbomMountPointPath = dbomMountPointPath2
	}
	return dbomMountPointPath, nil
}
func (c *DtoToDbomConverterImpl) sharedResourceToExportedShare(source dto.SharedResource) (dbom.ExportedShare, error) {
	var dbomExportedShare dbom.ExportedShare
	dbomExportedShare.Name = source.Name
	dbomExportedShare.Disabled = source.Disabled
	if source.Users != nil {
		dbomExportedShare.Users = make([]dbom.SambaUser, len(source.Users))
		for i := 0; i < len(source.Users); i++ {
			dbomSambaUser, err := c.userToSambaUser(source.Users[i])
			if err != nil {
				return dbomExportedShare, err
			}
			dbomExportedShare.Users[i] = dbomSambaUser
		}
	}
	if source.RoUsers != nil {
		dbomExportedShare.RoUsers = make([]dbom.SambaUser, len(source.RoUsers))
		for j := 0; j < len(source.RoUsers); j++ {
			dbomSambaUser2, err := c.userToSambaUser(source.RoUsers[j])
			if err != nil {
				return dbomExportedShare, err
			}
			dbomExportedShare.RoUsers[j] = dbomSambaUser2
		}
	}
	dbomExportedShare.VetoFiles = c.stringListToDatatypesJSONSlice(source.VetoFiles)
	if source.TimeMachine != nil {
		dbomExportedShare.TimeMachine = *source.TimeMachine
	}
	if source.RecycleBin != nil {
		dbomExportedShare.RecycleBin = *source.RecycleBin
	}
	if source.GuestOk != nil {
		dbomExportedShare.GuestOk = *source.GuestOk
	}
	if source.TimeMachineMaxSize != nil {
		dbomExportedShare.TimeMachineMaxSize = *source.TimeMachineMaxSize
	}
	dbomExportedShare.Usage = source.Usage
	var pString *string
	if source.MountPointData != nil {
		pString = &source.MountPointData.Path
	}
	if pString != nil {
		dbomExportedShare.MountPointDataPath = *pString
	}
	dbomMountPointPath, err := c.pDtoMountPointDataToDbomMountPointPath(source.MountPointData)
	if err != nil {
		return dbomExportedShare, err
	}
	dbomExportedShare.MountPointData = dbomMountPointPath
	return dbomExportedShare, nil
}
func (c *DtoToDbomConverterImpl) stringListToDatatypesJSONSlice(source []string) datatypes.JSONSlice[string] {
	var datatypesJSONSlice datatypes.JSONSlice[string]
	if source != nil {
		datatypesJSONSlice = make(datatypes.JSONSlice[string], len(source))
		for i := 0; i < len(source); i++ {
			datatypesJSONSlice[i] = source[i]
		}
	}
	return datatypesJSONSlice
}
func (c *DtoToDbomConverterImpl) userToSambaUser(source dto.User) (dbom.SambaUser, error) {
	var dbomSambaUser dbom.SambaUser
	dbomSambaUser.Username = source.Username
	dbomSambaUser.Password = source.Password
	dbomSambaUser.IsAdmin = source.IsAdmin
	if source.RwShares != nil {
		dbomSambaUser.RwShares = make([]dbom.ExportedShare, len(source.RwShares))
		for i := 0; i < len(source.RwShares); i++ {
			dbomSambaUser.RwShares[i] = stringToExportedShare(source.RwShares[i])
		}
	}
	if source.RoShares != nil {
		dbomSambaUser.RoShares = make([]dbom.ExportedShare, len(source.RoShares))
		for j := 0; j < len(source.RoShares); j++ {
			dbomSambaUser.RoShares[j] = stringToExportedShare(source.RoShares[j])
		}
	}
	return dbomSambaUser, nil
}
