// Code generated by github.com/jmattheis/goverter, DO NOT EDIT.
//go:build !goverter

package converter

import (
	"fmt"
	dbom "github.com/dianlight/srat/dbom"
	dto "github.com/dianlight/srat/dto"
)

type DtoToDbomConverterImpl struct{}

func (c *DtoToDbomConverterImpl) DtoMountPointDataToMountPointData(source dto.MountPointData, target *dbom.MountPointData) error {
	if source.ID != 0 {
		target.ID = source.ID
	}
	if source.Source != "" {
		target.Source = source.Source
	}
	if source.Path != "" {
		target.Path = source.Path
	}
	if source.FSType != "" {
		target.FSType = source.FSType
	}
	dtoMounDataFlags, err := c.dtoMounDataFlagsToDtoMounDataFlags(source.Flags)
	if err != nil {
		return err
	}
	target.Flags = dtoMounDataFlags
	if source.Invalid != false {
		target.Invalid = source.Invalid
	}
	if source.InvalidError != nil {
		xstring := *source.InvalidError
		target.InvalidError = &xstring
	}
	return nil
}
func (c *DtoToDbomConverterImpl) ExportedShareToSharedResourceNoMountPointData(source dbom.ExportedShare, target *dto.SharedResource) error {
	if source.ID != 0 {
		pUint := source.ID
		target.ID = &pUint
	}
	if source.Name != "" {
		target.Name = source.Name
	}
	if source.Disabled != false {
		target.Disabled = source.Disabled
	}
	if source.Users != nil {
		target.Users = make([]dto.User, len(source.Users))
		for i := 0; i < len(source.Users); i++ {
			target.Users[i] = c.dbomSambaUserToDtoUser(source.Users[i])
		}
	}
	if source.RoUsers != nil {
		target.RoUsers = make([]dto.User, len(source.RoUsers))
		for j := 0; j < len(source.RoUsers); j++ {
			target.RoUsers[j] = c.dbomSambaUserToDtoUser(source.RoUsers[j])
		}
	}
	if source.TimeMachine != false {
		target.TimeMachine = source.TimeMachine
	}
	if source.Usage != "" {
		dtoHAMountUsage, err := c.dtoHAMountUsageToDtoHAMountUsage(source.Usage)
		if err != nil {
			return err
		}
		target.Usage = dtoHAMountUsage
	}
	return nil
}
func (c *DtoToDbomConverterImpl) MountPointDataToDtoMountPointData(source dbom.MountPointData, target *dto.MountPointData) error {
	if source.ID != 0 {
		target.ID = source.ID
	}
	if source.Path != "" {
		target.Path = source.Path
	}
	if source.FSType != "" {
		target.FSType = source.FSType
	}
	dtoMounDataFlags, err := c.dtoMounDataFlagsToDtoMounDataFlags(source.Flags)
	if err != nil {
		return err
	}
	target.Flags = dtoMounDataFlags
	if source.Source != "" {
		target.Source = source.Source
	}
	if source.Invalid != false {
		target.Invalid = source.Invalid
	}
	if source.InvalidError != nil {
		xstring := *source.InvalidError
		target.InvalidError = &xstring
	}
	return nil
}
func (c *DtoToDbomConverterImpl) SambaUserToUser(source dbom.SambaUser, target *dto.User) error {
	pString := source.Username
	target.Username = &pString
	pString2 := source.Password
	target.Password = &pString2
	pBool := source.IsAdmin
	target.IsAdmin = &pBool
	return nil
}
func (c *DtoToDbomConverterImpl) SharedResourceToExportedShareNoUsersNoMountPointData(source dto.SharedResource, target *dbom.ExportedShare) error {
	if source.ID != nil {
		target.ID = *source.ID
	}
	if source.Name != "" {
		target.Name = source.Name
	}
	if source.Disabled != false {
		target.Disabled = source.Disabled
	}
	if source.TimeMachine != false {
		target.TimeMachine = source.TimeMachine
	}
	if source.Usage != "" {
		dtoHAMountUsage, err := c.dtoHAMountUsageToDtoHAMountUsage(source.Usage)
		if err != nil {
			return err
		}
		target.Usage = dtoHAMountUsage
	}
	return nil
}
func (c *DtoToDbomConverterImpl) UserToSambaUser(source dto.User, target *dbom.SambaUser) error {
	if source.Username != nil {
		target.Username = *source.Username
	}
	if source.Password != nil {
		target.Password = *source.Password
	}
	if source.IsAdmin != nil {
		target.IsAdmin = *source.IsAdmin
	}
	return nil
}
func (c *DtoToDbomConverterImpl) dbomSambaUserToDtoUser(source dbom.SambaUser) dto.User {
	var dtoUser dto.User
	pString := source.Username
	dtoUser.Username = &pString
	pString2 := source.Password
	dtoUser.Password = &pString2
	pBool := source.IsAdmin
	dtoUser.IsAdmin = &pBool
	return dtoUser
}
func (c *DtoToDbomConverterImpl) dtoHAMountUsageToDtoHAMountUsage(source dto.HAMountUsage) (dto.HAMountUsage, error) {
	var dtoHAMountUsage dto.HAMountUsage
	switch source {
	case dto.UsageAsBackup:
		dtoHAMountUsage = dto.UsageAsBackup
	case dto.UsageAsMedia:
		dtoHAMountUsage = dto.UsageAsMedia
	case dto.UsageAsNone:
		dtoHAMountUsage = dto.UsageAsNone
	case dto.UsageAsShare:
		dtoHAMountUsage = dto.UsageAsShare
	default:
		return dtoHAMountUsage, fmt.Errorf("unexpected enum element: %v", source)
	}
	return dtoHAMountUsage, nil
}
func (c *DtoToDbomConverterImpl) dtoMounDataFlagToDtoMounDataFlag(source dto.MounDataFlag) (dto.MounDataFlag, error) {
	var dtoMounDataFlag dto.MounDataFlag
	switch source {
	case dto.MS_BIND:
		dtoMounDataFlag = dto.MS_BIND
	case dto.MS_LAZYTIME:
		dtoMounDataFlag = dto.MS_LAZYTIME
	case dto.MS_MANDLOCK:
		dtoMounDataFlag = dto.MS_MANDLOCK
	case dto.MS_NOATIME:
		dtoMounDataFlag = dto.MS_NOATIME
	case dto.MS_NODEV:
		dtoMounDataFlag = dto.MS_NODEV
	case dto.MS_NODIRATIME:
		dtoMounDataFlag = dto.MS_NODIRATIME
	case dto.MS_NOEXEC:
		dtoMounDataFlag = dto.MS_NOEXEC
	case dto.MS_NOSUID:
		dtoMounDataFlag = dto.MS_NOSUID
	case dto.MS_NOUSER:
		dtoMounDataFlag = dto.MS_NOUSER
	case dto.MS_RDONLY:
		dtoMounDataFlag = dto.MS_RDONLY
	case dto.MS_RELATIME:
		dtoMounDataFlag = dto.MS_RELATIME
	case dto.MS_REMOUNT:
		dtoMounDataFlag = dto.MS_REMOUNT
	case dto.MS_SYNCHRONOUS:
		dtoMounDataFlag = dto.MS_SYNCHRONOUS
	default:
		return dtoMounDataFlag, fmt.Errorf("unexpected enum element: %v", source)
	}
	return dtoMounDataFlag, nil
}
func (c *DtoToDbomConverterImpl) dtoMounDataFlagsToDtoMounDataFlags(source dto.MounDataFlags) (dto.MounDataFlags, error) {
	var dtoMounDataFlags dto.MounDataFlags
	if source != nil {
		dtoMounDataFlags = make(dto.MounDataFlags, len(source))
		for i := 0; i < len(source); i++ {
			dtoMounDataFlag, err := c.dtoMounDataFlagToDtoMounDataFlag(source[i])
			if err != nil {
				return nil, err
			}
			dtoMounDataFlags[i] = dtoMounDataFlag
		}
	}
	return dtoMounDataFlags, nil
}
