# A revised and improved version of the GitHub Actions workflow.
# Key changes:
# 1. SAFER TAGGING: The "Update tag" step is now restricted to only run on dev builds.
# 2. CLEANER PERMISSIONS: Removed the unused "discussions: write" permission.
# 3. ROBUST DEV VERSIONING: The .devN suffix is now calculated by incrementing the last dev tag for the current version base.
# 4. MINOR CLEANUP: Added comments and removed redundant steps for clarity.

name: build

on:
  push:
    branches: ["main"]
    paths:
      - '**.go'
      - '**.ts'
      - '**.tsx'
      - '**/go.mod'
      - '**/go.sum'
      - '**/package.json'
      - '**/bun.lockb'
      - '**/Makefile'
      - 'bun.build.ts'
      - '.github/workflows/build.yaml'
  release:
    types: ["published"]
  pull_request:
    branches: ["main"]

# Permissions: Removed 'discussions: write' as it was unused.
permissions:
  contents: write

jobs:
  setversion:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.calculate_version.outputs.version }}
    name: Set version
    steps:
      - name: Checkout the repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0 # fetch-depth: 0 is required for git commands to see all history/tags

      - name: Calculate version
        id: calculate_version
        run: |
          set -euo pipefail

          if [[ "${{ github.event_name }}" == "release" && "${{ github.event.action }}" == "published" ]]; then
            VERSION="${{ github.event.release.tag_name }}"
            echo "Using release tag as version: $VERSION"
          else
            # Dev build version calculation
            CURRENT_YEAR=$(date -u +'%Y')
            CURRENT_MONTH=$(date -u +'%-m')
            CURRENT_PERIOD_PREFIX="${CURRENT_YEAR}.${CURRENT_MONTH}"

            echo "Fetching non-draft release tags for period ${CURRENT_PERIOD_PREFIX}..."
            # Get all tag_names from non-draft (published or pre-release) GitHub releases.
            # The `|| echo ""` ensures the script doesn't fail if gh api returns error or no releases.
            ALL_NON_DRAFT_RELEASE_TAGS_STRING=$(gh api --paginate /repos/${{ github.repository }}/releases -q '.[] | select(.draft == false) | .tag_name' || echo "")

            FILTERED_TAGS_LIST=()
            if [[ -n "$ALL_NON_DRAFT_RELEASE_TAGS_STRING" ]]; then
              while IFS= read -r tag; do
                # Ensure tag is not empty and matches the YYYY.M.* pattern for the current period.
                # This regex also ensures it's either a full release (YYYY.M.INC) or a dev release tag (YYYY.M.INC-dev.DEV).
                if [[ -n "$tag" && "$tag" =~ ^${CURRENT_PERIOD_PREFIX}\.([0-9]+)(-dev\.([0-9]+))?$ ]]; then
                  FILTERED_TAGS_LIST+=("$tag")
                fi
              done <<< "$ALL_NON_DRAFT_RELEASE_TAGS_STRING"
            fi

            TAGS_SORTED_STRING=""
            if [ ${#FILTERED_TAGS_LIST[@]} -gt 0 ]; then
              TAGS_SORTED_STRING=$(printf "%s\n" "${FILTERED_TAGS_LIST[@]}" | sed '/-/!{s/$/_/}' | sort -V | sed 's/_$//')
              echo "Found and sorted relevant tags from non-draft releases:"
              echo "${TAGS_SORTED_STRING}"
            else
              echo "No relevant non-draft release tags found for ${CURRENT_PERIOD_PREFIX} matching the versioning pattern."
            fi

            MAX_INC=-1 # Stores the 'INC' part of YYYY.M.INC or YYYY.M.INC-dev.N
            MAX_DEV_FOR_MAX_INC=-1 # Stores the 'DEV' part for the current MAX_INC if it's a dev series
            MAX_INC_IS_FULL_RELEASE=false # Flag to track if MAX_INC corresponds to a full release tag

            # Iterate over the sorted list of tags obtained from published releases.
            # If TAGS_SORTED_STRING is empty, this loop will not run.
            for TAG in $TAGS_SORTED_STRING; do
              if [[ "$TAG" =~ ^${CURRENT_PERIOD_PREFIX}\.([0-9]+)$ ]]; then # Matches a full release tag pattern: YYYY.M.INC
                INC=${BASH_REMATCH[1]}
                if (( INC > MAX_INC )); then
                  MAX_INC=$INC
                  MAX_DEV_FOR_MAX_INC=-1 # Reset dev part as this is a new, higher INC from a full release
                  MAX_INC_IS_FULL_RELEASE=true
                elif (( INC == MAX_INC )); then
                  # Encountered a full release tag for the current MAX_INC.
                  # This means this INC is finalized as a full release, overriding any prior dev status for this INC.
                  MAX_INC_IS_FULL_RELEASE=true
                  MAX_DEV_FOR_MAX_INC=-1 # Reset dev part
                fi
              elif [[ "$TAG" =~ ^${CURRENT_PERIOD_PREFIX}\.([0-9]+)-dev\.([0-9]+)$ ]]; then # Matches a dev tag pattern: YYYY.M.INC-dev.DEV
                INC=${BASH_REMATCH[1]}
                DEV=${BASH_REMATCH[2]}
                if (( INC > MAX_INC )); then
                  MAX_INC=$INC
                  MAX_DEV_FOR_MAX_INC=$DEV
                  MAX_INC_IS_FULL_RELEASE=false # This new MAX_INC is established by a dev tag
                elif (( INC == MAX_INC )); then
                  # Processing a dev tag for the current MAX_INC.
                  if $MAX_INC_IS_FULL_RELEASE; then
                    # MAX_INC was previously considered a full release (e.g., 2024.7.1 was processed).
                    # Now seeing a dev tag for it (e.g., 2024.7.1-dev.0).
                    # This means we're starting a dev series *for* this MAX_INC.
                    MAX_INC_IS_FULL_RELEASE=false # Mark that this INC is now on a dev track
                    MAX_DEV_FOR_MAX_INC=$DEV      # Start counting dev from this tag's DEV value
                  elif (( DEV > MAX_DEV_FOR_MAX_INC )); then
                    # Continue on the dev track for MAX_INC (MAX_INC_IS_FULL_RELEASE was already false)
                    MAX_DEV_FOR_MAX_INC=$DEV
                  fi
                fi
              fi
            done

            if (( MAX_INC == -1 )); then
              # No tags found for the current YYYY.MM period (e.g., 2024.7.*). Start with .0-dev.0.
              VERSION="${CURRENT_PERIOD_PREFIX}.0-dev.0"
            else
              if $MAX_INC_IS_FULL_RELEASE; then
                # The latest version component (MAX_INC) for this period was a full release (e.g., 2024.7.1).
                # So, the next dev version should increment the INC part and start with -dev.0.
                VERSION="${CURRENT_PERIOD_PREFIX}.$((MAX_INC + 1))-dev.0"
              else
                # The latest version component (MAX_INC) for this period was a dev series (e.g., 2024.7.1-dev.3).
                # So, increment the dev suffix for the current MAX_INC.
                VERSION="${CURRENT_PERIOD_PREFIX}.${MAX_INC}-dev.$((MAX_DEV_FOR_MAX_INC + 1))"
              fi
            fi
            echo "Calculated dev version: $VERSION"
          fi
          echo "Calculated version: $VERSION"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update CHANGELOG.md for release
        if: |
          github.event_name == 'release' &&
          github.event.action == 'published' &&
          !contains(steps.calculate_version.outputs.version, '-dev')
        run: |
          set -euo pipefail
          VERSION="${{ steps.calculate_version.outputs.version }}"
          
          # Check if CHANGELOG.md exists
          if [[ ! -f "CHANGELOG.md" ]]; then
            echo "CHANGELOG.md not found, skipping update"
            exit 0
          fi
          
          # Create a temporary file
          TEMP_FILE=$(mktemp)
          
          # Read the CHANGELOG and replace the Unreleased section with the version
          awk -v version="$VERSION" '
          BEGIN { found = 0 }
          {
            # If we find the Unreleased header and havent processed it yet
            if (!found && /^## \[ 🚧 Unreleased \]/) {
              found = 1
              # Replace with the version header
              print "## " version
              next
            }
            print $0
          }
          ' CHANGELOG.md > "$TEMP_FILE"
          
          # Replace the original file
          mv "$TEMP_FILE" CHANGELOG.md
          
          echo "CHANGELOG.md updated with version $VERSION"

      - name: Commit and push CHANGELOG.md
        if: |
          github.event_name == 'release' &&
          github.event.action == 'published' &&
          !contains(steps.calculate_version.outputs.version, '-dev')
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add CHANGELOG.md
          if git diff --staged --quiet; then
            echo "No changes to CHANGELOG.md"
          else
            git commit -m "chore: update CHANGELOG.md for release ${{ steps.calculate_version.outputs.version }}"
            git push origin HEAD:main
          fi

  test-backend:
    name: Test Backend
    runs-on: ubuntu-latest
    needs: setversion
    outputs:
      coverage: ${{ steps.extract_coverage.outputs.backend_coverage }}
    steps:
      - name: Checkout the repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0

      - name: Setup go
        uses: actions/setup-go@44694675825211faa026b3c33043df3e48a5fa00 # v6.0.0
        with:
          go-version-file: 'backend/src/go.mod'
          cache-dependency-path: "**/*.sum"

      - name: Prepare backend for ${{ needs.setversion.outputs.version }}
        run: |       
          cd backend
          make format
          cd ..

      - name: Test Backend ${{ needs.setversion.outputs.version }}
        # RECOMMENDATION: Investigate if 'sudo' is truly necessary for tests.
        # Running tests as root is a potential security risk.
        id: test_backend
        run: |
          set -o pipefail
          cd backend
          sudo -E PATH="$PATH" make test 2>&1 | tee backend_test_output.txt

      - name: Extract Backend Coverage
        id: extract_coverage
        run: |
          COVERAGE_LINE=$(grep "Total coverage:" backend/backend_test_output.txt | tail -1 || true)
          if [ -n "$COVERAGE_LINE" ]; then
            COVERAGE=$(echo "$COVERAGE_LINE" | awk '{gsub(/%/, "", $3); print $3}')
          else
            COVERAGE="0.0"
          fi
          echo "backend_coverage=$COVERAGE" >> "$GITHUB_OUTPUT"
          echo "Backend Coverage: $COVERAGE%"

  test-frontend:
    name: Test Frontend
    runs-on: ubuntu-latest
    needs: setversion
    outputs:
      coverage: ${{ steps.extract_coverage.outputs.frontend_coverage }}
    steps:
      - name: Checkout the repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0

      - uses: oven-sh/setup-bun@735343b667d3e6f658f44d0eca948eb6282f2b76 # v2
        with:
          bun-version-file: frontend/package.json

      - name: Prepare frontend for ${{ needs.setversion.outputs.version }}
        run: |       
          cd frontend
          bun install

      - name: Test Frontend ${{ needs.setversion.outputs.version }}
        id: test_frontend
        run: |
          set -o pipefail
          echo "Verifying setup.ts content before running tests (post-install):"
          if [ -f frontend/test/setup.ts ]; then
            echo "SHA1 and path for frontend/test/setup.ts:" && sha1sum frontend/test/setup.ts || true
            echo "Preview (first 20 lines):" && sed -n '1,20p' frontend/test/setup.ts || true
          else
            echo "frontend/test/setup.ts not found (pwd: $(pwd))"
            ls -la || true
          fi
          cd frontend
          bun test:ci 2>&1 | tee frontend_test_output.txt

      - name: Extract Frontend Coverage
        id: extract_coverage
        run: |
          COVERAGE_LINE=$(grep "All files" frontend/frontend_test_output.txt | tail -1 || true)
          if [ -n "$COVERAGE_LINE" ]; then
            COVERAGE=$(echo "$COVERAGE_LINE" | awk -F'|' '{gsub(/^[ \t]+|[ \t]+$/, "", $2); gsub(/%/, "", $2); print $2}')
          else
            COVERAGE="0.0"
          fi
          echo "frontend_coverage=$COVERAGE" >> "$GITHUB_OUTPUT"
          echo "Frontend Coverage: $COVERAGE%"

  update-coverage:
    name: Update Coverage Badges
    runs-on: ubuntu-latest
    needs: [setversion, test-backend, test-frontend]
    permissions:
      contents: write
    steps:
      - name: Checkout the repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - uses: oven-sh/setup-bun@735343b667d3e6f658f44d0eca948eb6282f2b76 # v2
        with:
          bun-version-file: frontend/package.json

      - name: Update coverage badges
        run: |
          bash scripts/update-coverage-badges.sh \
            --backend "${{ needs.test-backend.outputs.coverage }}" \
            --frontend "${{ needs.test-frontend.outputs.coverage }}"
          make docs

      - name: Check for changes
        id: check_changes
        run: |
          if git diff --quiet README.md docs/TEST_COVERAGE.md; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "No changes to coverage files"
          else
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "Coverage files have been updated"
          fi

      - name: Commit and push if changed
        if: |
          steps.check_changes.outputs.changed == 'true' &&
          github.event_name != 'pull_request'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Pull latest changes first
          git pull --rebase origin main || true
          
          git add README.md docs/TEST_COVERAGE.md
          git commit -m "🎯 test: update coverage badges [skip ci]"
          
          git push

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [setversion, test-backend, test-frontend, update-coverage]
    env:
      ROLLBAR_CLIENT_ACCESS_TOKEN: ${{ secrets.ROLLBAR_CLIENT_ACCESS_TOKEN || 'disabled' }}
      ROLLBAR_ENVIRONMENT: "production"
    steps:
      - name: Checkout the repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0

      - name: Setup go
        uses: actions/setup-go@44694675825211faa026b3c33043df3e48a5fa00 # v6.0.0
        with:
          go-version-file: 'backend/src/go.mod'
          cache-dependency-path: "**/*.sum"

      - uses: oven-sh/setup-bun@735343b667d3e6f658f44d0eca948eb6282f2b76 # v2
        with:
          bun-version-file: frontend/package.json

      - name: Prepare env for ${{ needs.setversion.outputs.version }}
        run: |       
          cd backend
          make format
          cd ../frontend
          bun install
          cd ..

      - name: Check if tag ${{ needs.setversion.outputs.version }} exists
        if: github.event_name != 'pull_request'
        id: checkTag
        uses: mukunku/tag-exists-action@bdad1eaa119ce71b150b952c97351c75025c06a9 # v1.6.0
        with:
          tag: '${{ needs.setversion.outputs.version }}'

      - name: Update dev tag ${{ needs.setversion.outputs.version }}
        # CRITICAL IMPROVEMENT: This step is now safer.
        # It will ONLY run if the tag already exists AND it's a dev build (version contains '.dev').
        # This prevents accidentally moving a final release tag.
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        if: |
          github.event_name != 'pull_request' &&
          steps.checkTag.outputs.exists == 'true' &&
          contains(needs.setversion.outputs.version, '-dev')
        with:
          script: |
            github.rest.git.updateRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: 'tags/${{ needs.setversion.outputs.version }}',
              sha: context.sha,
              force: true
            })

      - name: Create tag ${{ needs.setversion.outputs.version }}
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        if: ${{ github.event_name != 'pull_request' && steps.checkTag.outputs.exists == 'false' }}
        with:
          script: |
            github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: 'refs/tags/${{ needs.setversion.outputs.version }}',
              sha: context.sha
            })

      - name: BuildAll
        id: built_all
        if: github.event_name != 'pull_request'
        run: |
          sudo -E PATH="$PATH" make ALL VERSION=${{ needs.setversion.outputs.version }}

      - name: Prepare temporary directory for zips
        if: github.event_name != 'pull_request'
        run: mkdir -p /tmp/build_artifacts

      - name: Find architectures and create zip archives
        id: create_zips
        if: github.event_name != 'pull_request'
        run: |
          # This script finds each compiled architecture and zips it.
          for arch_dir in backend/dist/*/; do
            arch=$(basename "$arch_dir")
            zip_file_path="/tmp/build_artifacts/srat_${arch}.zip"
            echo "Processing architecture: ${arch}"
            if [ -d "$arch_dir" ]; then
              # zip preserves file modification times for entries by default. Using . is more robust for zipping directory contents.
              (cd "$arch_dir" && zip -r "$zip_file_path" .)
              echo "Successfully created ${zip_file_path}"
            else
              echo "Warning: Directory ${arch_dir} does not exist. Skipping."
            fi
          done

      - name: Upload binaries as artifact
        if: steps.built_all.conclusion == 'success'
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5
        with:
          name: binary-builds
          path: /tmp/build_artifacts/*.zip
          retention-days: 7
          overwrite: true

  create-release:
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request'
    needs: [build, setversion]
    steps:
      - name: Delete old draft releases
        uses: hugo19941994/delete-draft-releases@d375ad67d25fed7520a8020c3a6561fff5260c1e # v2.0.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53 # v6
        id: download_art
        with:
          name: binary-builds

      - name: Create Release and Upload Assets
        if: github.event_name != 'release' || github.event.action != 'published' || !github.event.release.prerelease
        uses: softprops/action-gh-release@6da8fa9354ddfdc4aeace5fc48d7f679b5214090 # v2
        with:
          tag_name: ${{ needs.setversion.outputs.version }}
          name: Release ${{ needs.setversion.outputs.version }}
          # Create a draft and pre-release for pushes to main, but a full release for 'release' events.
          draft: ${{ github.event_name != 'release' }}
          prerelease: ${{ github.event_name != 'release' || github.event.release.prerelease }}
          generate_release_notes: true
          files: ${{ steps.download_art.outputs.download-path }}/*

      - name: Checkout repository for CHANGELOG update
        if: |
          github.event_name == 'release' &&
          github.event.action == 'published' &&
          !contains(needs.setversion.outputs.version, '-dev')
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          ref: main
          fetch-depth: 1

      - name: Prepend new Unreleased section to CHANGELOG.md
        if: |
          github.event_name == 'release' &&
          github.event.action == 'published' &&
          !contains(needs.setversion.outputs.version, '-dev')
        run: |
          set -euo pipefail
          
          # Check if CHANGELOG.md exists
          if [[ ! -f "CHANGELOG.md" ]]; then
            echo "CHANGELOG.md not found, skipping update"
            exit 0
          fi
          
          # Create a temporary file
          TEMP_FILE=$(mktemp)
          
          # Read the CHANGELOG and prepend new Unreleased section at the top
          awk '
          BEGIN { header_found = 0 }
          {
            # Print the DOCTOC SKIP comment and title as-is
            if (NR <= 4 && /^(<!--.*-->|# Changelog|)$/) {
              print $0
              next
            }
            # After the header, insert the new Unreleased section
            if (!header_found && NR > 4) {
              header_found = 1
              print ""
              print "## [ 🚧 Unreleased ]"
              print ""
              print "### ✨ Features"
              print ""
              print "### 🐛 Bug Fixes"
              print ""
              print "### 🏗 Chore"
              print ""
            }
            print $0
          }
          ' CHANGELOG.md > "$TEMP_FILE"
          
          # Replace the original file
          mv "$TEMP_FILE" CHANGELOG.md
          
          echo "New Unreleased section prepended to CHANGELOG.md"

      - name: Commit and push new Unreleased section
        if: |
          github.event_name == 'release' &&
          github.event.action == 'published' &&
          !contains(needs.setversion.outputs.version, '-dev')
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add CHANGELOG.md
          if git diff --staged --quiet; then
            echo "No changes to CHANGELOG.md"
          else
            git commit -m "chore: add new Unreleased section to CHANGELOG.md"
            git push origin main
          fi
